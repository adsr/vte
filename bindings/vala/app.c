/* app.c generated by valac 0.34.9, the Vala compiler
 * generated from app.vala, do not modify */

/*
 * Copyright © 2001,2002 Red Hat, Inc.
 * Copyright © 2014 Christian Persch
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include "vte/vte.h"
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gdk/gdk.h>
#include <pango/pango.h>
#include <float.h>
#include <math.h>
#include <sys/types.h>
#include <unistd.h>
#include <locale.h>
#include "config.h"


#define TEST_TYPE_SEARCH_POPOVER (test_search_popover_get_type ())
#define TEST_SEARCH_POPOVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TEST_TYPE_SEARCH_POPOVER, TestSearchPopover))
#define TEST_SEARCH_POPOVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TEST_TYPE_SEARCH_POPOVER, TestSearchPopoverClass))
#define TEST_IS_SEARCH_POPOVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TEST_TYPE_SEARCH_POPOVER))
#define TEST_IS_SEARCH_POPOVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TEST_TYPE_SEARCH_POPOVER))
#define TEST_SEARCH_POPOVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TEST_TYPE_SEARCH_POPOVER, TestSearchPopoverClass))

typedef struct _TestSearchPopover TestSearchPopover;
typedef struct _TestSearchPopoverClass TestSearchPopoverClass;
typedef struct _TestSearchPopoverPrivate TestSearchPopoverPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vte_regex_unref0(var) ((var == NULL) ? NULL : (var = (vte_regex_unref (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TEST_TYPE_WINDOW (test_window_get_type ())
#define TEST_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TEST_TYPE_WINDOW, TestWindow))
#define TEST_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TEST_TYPE_WINDOW, TestWindowClass))
#define TEST_IS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TEST_TYPE_WINDOW))
#define TEST_IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TEST_TYPE_WINDOW))
#define TEST_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TEST_TYPE_WINDOW, TestWindowClass))

typedef struct _TestWindow TestWindow;
typedef struct _TestWindowClass TestWindowClass;
typedef struct _TestWindowPrivate TestWindowPrivate;

#define TEST_TYPE_APP (test_app_get_type ())
#define TEST_APP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TEST_TYPE_APP, TestApp))
#define TEST_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TEST_TYPE_APP, TestAppClass))
#define TEST_IS_APP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TEST_TYPE_APP))
#define TEST_IS_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TEST_TYPE_APP))
#define TEST_APP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TEST_TYPE_APP, TestAppClass))

typedef struct _TestApp TestApp;
typedef struct _TestAppClass TestAppClass;
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
#define __vala_PangoFontDescription_free0(var) ((var == NULL) ? NULL : (var = (_vala_PangoFontDescription_free (var), NULL)))
typedef struct _Block1Data Block1Data;
typedef struct _TestAppPrivate TestAppPrivate;
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))

#define TEST_APP_TYPE_OPTIONS (test_app_options_get_type ())
typedef struct _TestAppOptions TestAppOptions;
#define _g_type_class_unref0(var) ((var == NULL) ? NULL : (var = (g_type_class_unref (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _TestSearchPopover {
	GtkPopover parent_instance;
	TestSearchPopoverPrivate * priv;
};

struct _TestSearchPopoverClass {
	GtkPopoverClass parent_class;
};

struct _TestSearchPopoverPrivate {
	VteTerminal* _terminal;
	GtkSearchEntry* search_entry;
	GtkButton* search_prev_button;
	GtkButton* search_next_button;
	GtkButton* close_button;
	GtkToggleButton* match_case_checkbutton;
	GtkToggleButton* entire_word_checkbutton;
	GtkToggleButton* regex_checkbutton;
	GtkToggleButton* wrap_around_checkbutton;
	GtkButton* reveal_button;
	GtkRevealer* revealer;
	gboolean regex_caseless;
	gchar* regex_pattern;
	gboolean has_regex;
};

struct _TestWindow {
	GtkApplicationWindow parent_instance;
	TestWindowPrivate * priv;
};

struct _TestWindowClass {
	GtkApplicationWindowClass parent_class;
};

struct _TestWindowPrivate {
	GtkScrollbar* scrollbar;
	GtkBox* terminal_box;
	GtkWidget* readonly_emblem;
	GtkToggleButton* find_button;
	GtkMenuButton* gear_button;
	VteTerminal* terminal;
	GtkClipboard* clipboard;
	GPid child_pid;
	TestSearchPopover* search_popover;
	guint launch_idle_id;
	gchar** builtin_dingus;
	gint builtin_dingus_length1;
	gint _builtin_dingus_size_;
};

struct _Block1Data {
	int _ref_count_;
	TestWindow* self;
	gchar** argv;
	gint argv_length1;
	gint _argv_size_;
};

struct _TestApp {
	GtkApplication parent_instance;
	TestAppPrivate * priv;
};

struct _TestAppClass {
	GtkApplicationClass parent_class;
};

struct _TestAppOptions {
};


static gpointer test_search_popover_parent_class = NULL;
extern gboolean test_app_options_no_pcre;
static gpointer test_window_parent_class = NULL;
extern gint test_app_options_extra_margin;
extern gint test_app_options_transparency_percent;
extern gboolean test_app_options_no_argb_visual;
extern gboolean test_app_options_object_notifications;
extern gboolean test_app_options_no_double_buffer;
extern gchar* test_app_options_encoding;
extern gchar* test_app_options_word_char_exceptions;
extern gboolean test_app_options_audible;
extern gboolean test_app_options_no_rewrap;
extern gint test_app_options_scrollback_lines;
extern gchar* test_app_options_font_string;
extern gboolean test_app_options_no_builtin_dingus;
extern gchar** test_app_options_dingus;
extern gint test_app_options_dingus_length1;
extern gchar* test_app_options_geometry;
extern gchar* test_app_options_working_directory;
extern gchar** test_app_options_environment;
extern gint test_app_options_environment_length1;
extern gchar* test_app_options_command;
extern gboolean test_app_options_no_shell;
extern gboolean test_app_options_no_geometry_hints;
extern gboolean test_app_options_no_context_menu;
extern gchar* test_app_options_output_filename;
extern gboolean test_app_options_keep;
static gpointer test_app_parent_class = NULL;
extern gint test_app_options_n_windows;
extern gchar* test_app_options_cjk_ambiguous_width_string;
extern gchar* test_app_options_cursor_blink_mode_string;
extern gchar* test_app_options_cursor_background_color_string;
extern gchar* test_app_options_cursor_foreground_color_string;
extern gchar* test_app_options_cursor_shape_string;
extern gboolean test_app_options_debug;
extern gchar* test_app_options_hl_bg_color_string;
extern gchar* test_app_options_hl_fg_color_string;
extern gchar* test_app_options_icon_title;
extern gboolean test_app_options_reverse;
extern gboolean test_app_options_version;
gboolean test_app_options_audible = FALSE;
gchar* test_app_options_command = NULL;
gchar* test_app_options_cjk_ambiguous_width_string = NULL;
gchar* test_app_options_cursor_blink_mode_string = NULL;
gchar* test_app_options_cursor_background_color_string = NULL;
gchar* test_app_options_cursor_foreground_color_string = NULL;
gchar* test_app_options_cursor_shape_string = NULL;
gchar** test_app_options_dingus = NULL;
gint test_app_options_dingus_length1 = 0;
static gint _test_app_options_dingus_size_ = 0;
gboolean test_app_options_debug = FALSE;
gchar* test_app_options_encoding = NULL;
gchar** test_app_options_environment = NULL;
gint test_app_options_environment_length1 = 0;
static gint _test_app_options_environment_size_ = 0;
gint test_app_options_extra_margin = 0;
gchar* test_app_options_font_string = NULL;
gchar* test_app_options_geometry = NULL;
gchar* test_app_options_hl_bg_color_string = NULL;
gchar* test_app_options_hl_fg_color_string = NULL;
gchar* test_app_options_icon_title = NULL;
gboolean test_app_options_keep = FALSE;
gboolean test_app_options_no_argb_visual = FALSE;
gboolean test_app_options_no_builtin_dingus = FALSE;
gboolean test_app_options_no_context_menu = FALSE;
gboolean test_app_options_no_double_buffer = FALSE;
gboolean test_app_options_no_geometry_hints = FALSE;
gboolean test_app_options_no_pcre = FALSE;
gboolean test_app_options_no_rewrap = FALSE;
gboolean test_app_options_no_shell = FALSE;
gboolean test_app_options_object_notifications = FALSE;
gchar* test_app_options_output_filename = NULL;
gboolean test_app_options_reverse = FALSE;
gint test_app_options_scrollback_lines = 512;
gint test_app_options_transparency_percent = 0;
gboolean test_app_options_version = FALSE;
gint test_app_options_n_windows = 1;
gchar* test_app_options_word_char_exceptions = NULL;
gchar* test_app_options_working_directory = NULL;

GType test_search_popover_get_type (void) G_GNUC_CONST;
#define TEST_SEARCH_POPOVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TEST_TYPE_SEARCH_POPOVER, TestSearchPopoverPrivate))
enum  {
	TEST_SEARCH_POPOVER_DUMMY_PROPERTY,
	TEST_SEARCH_POPOVER_TERMINAL
};
TestSearchPopover* test_search_popover_new (VteTerminal* term, GtkWidget* relative_to);
TestSearchPopover* test_search_popover_construct (GType object_type, VteTerminal* term, GtkWidget* relative_to);
static void __lambda4_ (TestSearchPopover* self);
static void ___lambda4__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void __lambda5_ (TestSearchPopover* self);
static void test_search_popover_search (TestSearchPopover* self, gboolean backward);
static void ___lambda5__gtk_search_entry_next_match (GtkSearchEntry* _sender, gpointer self);
static void __lambda6_ (TestSearchPopover* self);
static void ___lambda6__gtk_search_entry_previous_match (GtkSearchEntry* _sender, gpointer self);
static void __lambda7_ (TestSearchPopover* self);
static void test_search_popover_update_regex (TestSearchPopover* self);
static void ___lambda7__gtk_search_entry_search_changed (GtkSearchEntry* _sender, gpointer self);
static void __lambda12_ (TestSearchPopover* self);
static void ___lambda12__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void __lambda13_ (TestSearchPopover* self);
static void ___lambda13__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void __lambda14_ (TestSearchPopover* self);
static void ___lambda14__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void __lambda15_ (TestSearchPopover* self);
static void ___lambda15__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void __lambda16_ (TestSearchPopover* self);
static void ___lambda16__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void __lambda17_ (TestSearchPopover* self);
VteTerminal* test_search_popover_get_terminal (TestSearchPopover* self);
static void ___lambda17__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void test_search_popover_update_sensitivity (TestSearchPopover* self);
static gboolean test_search_popover_have_regex (TestSearchPopover* self);
void test_search_popover_set_terminal (TestSearchPopover* self, VteTerminal* value);
static void test_search_popover_finalize (GObject* obj);
static void _vala_test_search_popover_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_test_search_popover_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType test_window_get_type (void) G_GNUC_CONST;
#define TEST_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TEST_TYPE_WINDOW, TestWindowPrivate))
enum  {
	TEST_WINDOW_DUMMY_PROPERTY
};
static void test_window_action_copy_cb (TestWindow* self);
static void _test_window_action_copy_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void test_window_action_copy_match_cb (TestWindow* self, GSimpleAction* action, GVariant* parameter);
static void _test_window_action_copy_match_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void test_window_action_paste_cb (TestWindow* self);
static void _test_window_action_paste_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void test_window_action_reset_cb (TestWindow* self, GSimpleAction* action, GVariant* parameter);
static void _test_window_action_reset_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void test_window_action_find_cb (TestWindow* self);
static void _test_window_action_find_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void test_window_action_quit_cb (TestWindow* self);
static void _test_window_action_quit_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
GType test_app_get_type (void) G_GNUC_CONST;
TestWindow* test_window_new (TestApp* app);
TestWindow* test_window_construct (GType object_type, TestApp* app);
static void __lambda8_ (TestWindow* self, GObject* obj, GParamSpec* pspec);
static void ___lambda8__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void __lambda9_ (TestWindow* self);
static void ___lambda9__gtk_popover_closed (GtkPopover* _sender, gpointer self);
static void __lambda10_ (TestWindow* self);
static void ___lambda10__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void test_window_clipboard_owner_change_cb (TestWindow* self, GtkClipboard* clipboard, GdkEvent* event);
static void _test_window_clipboard_owner_change_cb_gtk_clipboard_owner_change (GtkClipboard* _sender, GdkEvent* p0, gpointer self);
static gboolean test_window_popup_menu_cb (TestWindow* self);
static gboolean _test_window_popup_menu_cb_gtk_widget_popup_menu (GtkWidget* _sender, gpointer self);
static gboolean test_window_button_press_event_cb (TestWindow* self, GtkWidget* widget, GdkEventButton* event);
static gboolean _test_window_button_press_event_cb_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static void test_window_char_size_changed_cb (TestWindow* self, VteTerminal* terminal, guint width, guint height);
static void _test_window_char_size_changed_cb_vte_terminal_char_size_changed (VteTerminal* _sender, guint char_width, guint char_height, gpointer self);
static void test_window_child_exited_cb (TestWindow* self, VteTerminal* terminal, gint status);
static void _test_window_child_exited_cb_vte_terminal_child_exited (VteTerminal* _sender, gint status, gpointer self);
static void test_window_decrease_font_size_cb (TestWindow* self, VteTerminal* terminal);
static void _test_window_decrease_font_size_cb_vte_terminal_decrease_font_size (VteTerminal* _sender, gpointer self);
void test_window_deiconify_window_cb (TestWindow* self, VteTerminal* terminal);
static void _test_window_deiconify_window_cb_vte_terminal_deiconify_window (VteTerminal* _sender, gpointer self);
static void test_window_icon_title_changed_cb (TestWindow* self, VteTerminal* terminal);
static void _test_window_icon_title_changed_cb_vte_terminal_icon_title_changed (VteTerminal* _sender, gpointer self);
static void test_window_iconify_window_cb (TestWindow* self, VteTerminal* terminal);
static void _test_window_iconify_window_cb_vte_terminal_iconify_window (VteTerminal* _sender, gpointer self);
static void test_window_increase_font_size_cb (TestWindow* self, VteTerminal* terminal);
static void _test_window_increase_font_size_cb_vte_terminal_increase_font_size (VteTerminal* _sender, gpointer self);
static void test_window_lower_window_cb (TestWindow* self, VteTerminal* terminal);
static void _test_window_lower_window_cb_vte_terminal_lower_window (VteTerminal* _sender, gpointer self);
static void test_window_maximize_window_cb (TestWindow* self, VteTerminal* terminal);
static void _test_window_maximize_window_cb_vte_terminal_maximize_window (VteTerminal* _sender, gpointer self);
static void test_window_move_window_cb (TestWindow* self, VteTerminal* terminal, guint x, guint y);
static void _test_window_move_window_cb_vte_terminal_move_window (VteTerminal* _sender, guint x, guint y, gpointer self);
static void test_window_raise_window_cb (TestWindow* self, VteTerminal* terminal);
static void _test_window_raise_window_cb_vte_terminal_raise_window (VteTerminal* _sender, gpointer self);
static void test_window_realize_cb (TestWindow* self, GtkWidget* widget);
static void _test_window_realize_cb_gtk_widget_realize (GtkWidget* _sender, gpointer self);
static void test_window_refresh_window_cb (TestWindow* self, VteTerminal* terminal);
static void _test_window_refresh_window_cb_vte_terminal_refresh_window (VteTerminal* _sender, gpointer self);
static void test_window_resize_window_cb (TestWindow* self, VteTerminal* terminal, guint columns, guint rows);
static void _test_window_resize_window_cb_vte_terminal_resize_window (VteTerminal* _sender, guint width, guint height, gpointer self);
static void test_window_restore_window_cb (TestWindow* self, VteTerminal* terminal);
static void _test_window_restore_window_cb_vte_terminal_restore_window (VteTerminal* _sender, gpointer self);
static void test_window_selection_changed_cb (TestWindow* self, VteTerminal* terminal);
static void _test_window_selection_changed_cb_vte_terminal_selection_changed (VteTerminal* _sender, gpointer self);
static void test_window_window_title_changed_cb (TestWindow* self, VteTerminal* terminal);
static void _test_window_window_title_changed_cb_vte_terminal_window_title_changed (VteTerminal* _sender, gpointer self);
static void test_window_notify_cb (TestWindow* self, GObject* object, GParamSpec* pspec);
static void _test_window_notify_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
gint test_app_options_get_cjk_ambiguous_width (void);
VteCursorBlinkMode test_app_options_get_cursor_blink_mode (void);
VteCursorShape test_app_options_get_cursor_shape (void);
static void _vala_PangoFontDescription_free (PangoFontDescription* self);
void test_app_options_get_color_fg (GdkRGBA* result);
void test_app_options_get_color_bg (GdkRGBA* result);
GdkRGBA* test_app_options_get_color_cursor_background (void);
GdkRGBA* test_app_options_get_color_cursor_foreground (void);
GdkRGBA* test_app_options_get_color_hl_bg (void);
GdkRGBA* test_app_options_get_color_hl_fg (void);
static void test_window_add_dingus (TestWindow* self, gchar** dingus, int dingus_length1);
static void test_window_update_paste_sensitivity (TestWindow* self);
static void test_window_update_copy_sensitivity (TestWindow* self);
static void test_window_adjust_font_size (TestWindow* self, gdouble factor);
static void test_window_update_geometry (TestWindow* self);
void test_window_apply_geometry (TestWindow* self);
static void test_window_launch_command (TestWindow* self, const gchar* command, GError** error);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gboolean __lambda11_ (Block1Data* _data1_);
static gboolean ___lambda11__gsource_func (gpointer self);
static void test_window_launch_shell (TestWindow* self, GError** error);
static void test_window_fork (TestWindow* self, GError** error);
void test_window_launch (TestWindow* self);
static gboolean test_window_show_context_menu (TestWindow* self, guint button, guint32 timestamp, GdkEvent* event);
static void test_window_finalize (GObject* obj);
enum  {
	TEST_APP_DUMMY_PROPERTY
};
TestApp* test_app_new (void);
TestApp* test_app_construct (GType object_type);
static void test_app_real_startup (GApplication* base);
static void test_app_real_activate (GApplication* base);
gint test_app_main (gchar** argv, int argv_length1);
GType test_app_options_get_type (void) G_GNUC_CONST;
TestAppOptions* test_app_options_dup (const TestAppOptions* self);
void test_app_options_free (TestAppOptions* self);
static gint test_app_options_parse_enum (GType type, const gchar* str);
static GdkRGBA* test_app_options_get_color (const gchar* str);
static GdkRGBA* _gdk_rgba_dup (GdkRGBA* self);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

static const GActionEntry TEST_WINDOW_action_entries[6] = {{"copy", _test_window_action_copy_cb_gsimple_action_activate_callback}, {"copy-match", _test_window_action_copy_match_cb_gsimple_action_activate_callback, "s"}, {"paste", _test_window_action_paste_cb_gsimple_action_activate_callback}, {"reset", _test_window_action_reset_cb_gsimple_action_activate_callback, "b"}, {"find", _test_window_action_find_cb_gsimple_action_activate_callback}, {"quit", _test_window_action_quit_cb_gsimple_action_activate_callback}};
const GOptionEntry TEST_APP_OPTIONS_entries[36] = {{"audible-bell", 'a', 0, G_OPTION_ARG_NONE, &test_app_options_audible, "Use audible terminal bell", NULL}, {"command", 'c', 0, G_OPTION_ARG_STRING, &test_app_options_command, "Execute a command in the terminal", NULL}, {"cjk-width", (gchar) 0, 0, G_OPTION_ARG_STRING, &test_app_options_cjk_ambiguous_width_string, "Specify the cjk ambiguous width to use for UTF-8 encoding", "NARROW|WIDE"}, {"cursor-blink", (gchar) 0, 0, G_OPTION_ARG_STRING, &test_app_options_cursor_blink_mode_string, "Cursor blink mode (system|on|off)", "MODE"}, {"cursor-background-color", (gchar) 0, 0, G_OPTION_ARG_STRING, &test_app_options_cursor_background_color_string, "Enable a colored cursor background", NULL}, {"cursor-foreground-color", (gchar) 0, 0, G_OPTION_ARG_STRING, &test_app_options_cursor_foreground_color_string, "Enable a colored cursor foreground", NULL}, {"cursor-shape", (gchar) 0, 0, G_OPTION_ARG_STRING, &test_app_options_cursor_shape_string, "Set cursor shape (block|underline|ibeam)", NULL}, {"dingu", 'D', 0, G_OPTION_ARG_STRING_ARRAY, &test_app_options_dingus, "Add regex highlight", NULL}, {"debug", 'd', 0, G_OPTION_ARG_NONE, &test_app_options_debug, "Enable various debugging checks", NULL}, {"encoding", (gchar) 0, 0, G_OPTION_ARG_STRING, &test_app_options_encoding, "Specify the terminal encoding to use", NULL}, {"env", (gchar) 0, 0, G_OPTION_ARG_STRING_ARRAY, &test_app_options_environment, "Add environment variable to the child\'s environment", "VAR=VALUE"}, {"extra-margin", (gchar) 0, 0, G_OPTION_ARG_INT, &test_app_options_extra_margin, "Add extra margin around the terminal widget", "MARGIN"}, {"font", 'f', 0, G_OPTION_ARG_STRING, &test_app_options_font_string, "Specify a font to use", NULL}, {"gregex", (gchar) 0, 0, G_OPTION_ARG_NONE, &test_app_options_no_pcre, "Use GRegex instead of PCRE2", NULL}, {"geometry", 'g', 0, G_OPTION_ARG_STRING, &test_app_options_geometry, "Set the size (in characters) and position", "GEOMETRY"}, {"highlight-background-color", (gchar) 0, 0, G_OPTION_ARG_STRING, &test_app_options_hl_bg_color_string, "Enable distinct highlight background color for selection", NULL}, {"highlight-foreground-color", (gchar) 0, 0, G_OPTION_ARG_STRING, &test_app_options_hl_fg_color_string, "Enable distinct highlight foreground color for selection", NULL}, {"icon-title", 'i', 0, G_OPTION_ARG_NONE, &test_app_options_icon_title, "Enable the setting of the icon title", NULL}, {"keep", 'k', 0, G_OPTION_ARG_NONE, &test_app_options_keep, "Live on after the command exits", NULL}, {"no-argb-visual", (gchar) 0, 0, G_OPTION_ARG_NONE, &test_app_options_no_argb_visual, "Don't use an ARGB visual", NULL}, {"no-builtin-dingus", (gchar) 0, 0, G_OPTION_ARG_NONE, &test_app_options_no_builtin_dingus, "Highlight URLs inside the terminal", NULL}, {"no-context-menu", (gchar) 0, 0, G_OPTION_ARG_NONE, &test_app_options_no_context_menu, "Disable context menu", NULL}, {"no-double-buffer", '2', 0, G_OPTION_ARG_NONE, &test_app_options_no_double_buffer, "Disable double-buffering", NULL}, {"no-geometry-hints", 'G', 0, G_OPTION_ARG_NONE, &test_app_options_no_geometry_hints, "Allow the terminal to be resized to any dimension, not constrained to " \
"fit to an integer multiple of characters", NULL}, {"no-rewrap", 'R', 0, G_OPTION_ARG_NONE, &test_app_options_no_rewrap, "Disable rewrapping on resize", NULL}, {"no-shell", 'S', 0, G_OPTION_ARG_NONE, &test_app_options_no_shell, "Disable spawning a shell inside the terminal", NULL}, {"object-notifications", 'N', 0, G_OPTION_ARG_NONE, &test_app_options_object_notifications, "Print VteTerminal object notifications", NULL}, {"output-file", (gchar) 0, 0, G_OPTION_ARG_FILENAME, &test_app_options_output_filename, "Save terminal contents to file at exit", NULL}, {"reverse", (gchar) 0, 0, G_OPTION_ARG_NONE, &test_app_options_reverse, "Reverse foreground/background colors", NULL}, {"scrollback-lines", 'n', 0, G_OPTION_ARG_INT, &test_app_options_scrollback_lines, "Specify the number of scrollback-lines", NULL}, {"transparent", 'T', 0, G_OPTION_ARG_INT, &test_app_options_transparency_percent, "Enable the use of a transparent background", "0..100"}, {"version", (gchar) 0, 0, G_OPTION_ARG_NONE, &test_app_options_version, "Show version", NULL}, {"windows", (gchar) 0, 0, G_OPTION_ARG_INT, &test_app_options_n_windows, "Open multiple windows (default: 1)", "NUMBER"}, {"word-char-exceptions", (gchar) 0, 0, G_OPTION_ARG_STRING, &test_app_options_word_char_exceptions, "Specify the word char exceptions", "CHARS"}, {"working-directory", 'w', 0, G_OPTION_ARG_FILENAME, &test_app_options_working_directory, "Specify the initial working directory of the terminal", NULL}, {NULL}};

static void __lambda4_ (TestSearchPopover* self) {
	gtk_widget_hide ((GtkWidget*) self);
}


static void ___lambda4__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda4_ ((TestSearchPopover*) self);
}


static void __lambda5_ (TestSearchPopover* self) {
	test_search_popover_search (self, FALSE);
}


static void ___lambda5__gtk_search_entry_next_match (GtkSearchEntry* _sender, gpointer self) {
	__lambda5_ ((TestSearchPopover*) self);
}


static void __lambda6_ (TestSearchPopover* self) {
	test_search_popover_search (self, TRUE);
}


static void ___lambda6__gtk_search_entry_previous_match (GtkSearchEntry* _sender, gpointer self) {
	__lambda6_ ((TestSearchPopover*) self);
}


static void __lambda7_ (TestSearchPopover* self) {
	test_search_popover_update_regex (self);
}


static void ___lambda7__gtk_search_entry_search_changed (GtkSearchEntry* _sender, gpointer self) {
	__lambda7_ ((TestSearchPopover*) self);
}


static void __lambda12_ (TestSearchPopover* self) {
	test_search_popover_search (self, FALSE);
}


static void ___lambda12__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda12_ ((TestSearchPopover*) self);
}


static void __lambda13_ (TestSearchPopover* self) {
	test_search_popover_search (self, TRUE);
}


static void ___lambda13__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda13_ ((TestSearchPopover*) self);
}


static void __lambda14_ (TestSearchPopover* self) {
	test_search_popover_update_regex (self);
}


static void ___lambda14__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	__lambda14_ ((TestSearchPopover*) self);
}


static void __lambda15_ (TestSearchPopover* self) {
	test_search_popover_update_regex (self);
}


static void ___lambda15__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	__lambda15_ ((TestSearchPopover*) self);
}


static void __lambda16_ (TestSearchPopover* self) {
	test_search_popover_update_regex (self);
}


static void ___lambda16__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	__lambda16_ ((TestSearchPopover*) self);
}


static void __lambda17_ (TestSearchPopover* self) {
	VteTerminal* _tmp0_ = NULL;
	GtkToggleButton* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	_tmp0_ = self->priv->_terminal;
	_tmp1_ = self->priv->wrap_around_checkbutton;
	_tmp2_ = gtk_toggle_button_get_active (_tmp1_);
	_tmp3_ = _tmp2_;
	vte_terminal_search_set_wrap_around (_tmp0_, _tmp3_);
}


static void ___lambda17__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	__lambda17_ ((TestSearchPopover*) self);
}


TestSearchPopover* test_search_popover_construct (GType object_type, VteTerminal* term, GtkWidget* relative_to) {
	TestSearchPopover * self = NULL;
	GtkWidget* _tmp0_ = NULL;
	VteTerminal* _tmp1_ = NULL;
	GtkButton* _tmp2_ = NULL;
	GtkButton* _tmp3_ = NULL;
	GtkRevealer* _tmp4_ = NULL;
	GtkSearchEntry* _tmp5_ = NULL;
	GtkSearchEntry* _tmp6_ = NULL;
	GtkSearchEntry* _tmp7_ = NULL;
	GtkButton* _tmp8_ = NULL;
	GtkButton* _tmp9_ = NULL;
	GtkToggleButton* _tmp10_ = NULL;
	GtkToggleButton* _tmp11_ = NULL;
	GtkToggleButton* _tmp12_ = NULL;
	GtkToggleButton* _tmp13_ = NULL;
	g_return_val_if_fail (term != NULL, NULL);
	g_return_val_if_fail (relative_to != NULL, NULL);
	_tmp0_ = relative_to;
	_tmp1_ = term;
	self = (TestSearchPopover*) g_object_new (object_type, "relative-to", _tmp0_, "terminal", _tmp1_, NULL);
	_tmp2_ = self->priv->close_button;
	g_signal_connect_object (_tmp2_, "clicked", (GCallback) ___lambda4__gtk_button_clicked, self, 0);
	_tmp3_ = self->priv->reveal_button;
	_tmp4_ = self->priv->revealer;
	g_object_bind_property_with_closures ((GObject*) _tmp3_, "active", (GObject*) _tmp4_, "reveal-child", G_BINDING_DEFAULT, (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, (GClosureNotify) NULL)), (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, (GClosureNotify) NULL)));
	_tmp5_ = self->priv->search_entry;
	g_signal_connect_object (_tmp5_, "next-match", (GCallback) ___lambda5__gtk_search_entry_next_match, self, 0);
	_tmp6_ = self->priv->search_entry;
	g_signal_connect_object (_tmp6_, "previous-match", (GCallback) ___lambda6__gtk_search_entry_previous_match, self, 0);
	_tmp7_ = self->priv->search_entry;
	g_signal_connect_object (_tmp7_, "search-changed", (GCallback) ___lambda7__gtk_search_entry_search_changed, self, 0);
	_tmp8_ = self->priv->search_next_button;
	g_signal_connect_object (_tmp8_, "clicked", (GCallback) ___lambda12__gtk_button_clicked, self, 0);
	_tmp9_ = self->priv->search_prev_button;
	g_signal_connect_object (_tmp9_, "clicked", (GCallback) ___lambda13__gtk_button_clicked, self, 0);
	_tmp10_ = self->priv->match_case_checkbutton;
	g_signal_connect_object (_tmp10_, "toggled", (GCallback) ___lambda14__gtk_toggle_button_toggled, self, 0);
	_tmp11_ = self->priv->entire_word_checkbutton;
	g_signal_connect_object (_tmp11_, "toggled", (GCallback) ___lambda15__gtk_toggle_button_toggled, self, 0);
	_tmp12_ = self->priv->regex_checkbutton;
	g_signal_connect_object (_tmp12_, "toggled", (GCallback) ___lambda16__gtk_toggle_button_toggled, self, 0);
	_tmp13_ = self->priv->wrap_around_checkbutton;
	g_signal_connect_object (_tmp13_, "toggled", (GCallback) ___lambda17__gtk_toggle_button_toggled, self, 0);
	test_search_popover_update_sensitivity (self);
	return self;
}


TestSearchPopover* test_search_popover_new (VteTerminal* term, GtkWidget* relative_to) {
	return test_search_popover_construct (TEST_TYPE_SEARCH_POPOVER, term, relative_to);
}


static gboolean test_search_popover_have_regex (TestSearchPopover* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->has_regex;
	result = _tmp0_;
	return result;
}


static void test_search_popover_update_sensitivity (TestSearchPopover* self) {
	gboolean can_search = FALSE;
	gboolean _tmp0_ = FALSE;
	GtkButton* _tmp1_ = NULL;
	GtkButton* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = test_search_popover_have_regex (self);
	can_search = _tmp0_;
	_tmp1_ = self->priv->search_prev_button;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp1_, can_search);
	_tmp2_ = self->priv->search_next_button;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp2_, can_search);
}


static void test_search_popover_update_regex (TestSearchPopover* self) {
	gchar* search_text = NULL;
	gchar* pattern = NULL;
	gboolean caseless = FALSE;
	GRegex* gregex = NULL;
	VteRegex* regex = NULL;
	GtkSearchEntry* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	GtkToggleButton* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	GtkToggleButton* _tmp6_ = NULL;
	gboolean _tmp7_ = FALSE;
	gboolean _tmp8_ = FALSE;
	GtkToggleButton* _tmp13_ = NULL;
	gboolean _tmp14_ = FALSE;
	gboolean _tmp15_ = FALSE;
	gboolean _tmp20_ = FALSE;
	gboolean _tmp21_ = FALSE;
	gboolean _tmp22_ = FALSE;
	gboolean _tmp25_ = FALSE;
	const gchar* _tmp26_ = NULL;
	gint _tmp27_ = 0;
	gint _tmp28_ = 0;
	gboolean _tmp61_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	pattern = NULL;
	caseless = FALSE;
	gregex = NULL;
	regex = NULL;
	_tmp0_ = self->priv->search_entry;
	_tmp1_ = gtk_entry_get_text ((GtkEntry*) _tmp0_);
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (search_text);
	search_text = _tmp2_;
	_tmp3_ = self->priv->match_case_checkbutton;
	_tmp4_ = gtk_toggle_button_get_active (_tmp3_);
	_tmp5_ = _tmp4_;
	caseless = !_tmp5_;
	_tmp6_ = self->priv->regex_checkbutton;
	_tmp7_ = gtk_toggle_button_get_active (_tmp6_);
	_tmp8_ = _tmp7_;
	if (_tmp8_) {
		const gchar* _tmp9_ = NULL;
		gchar* _tmp10_ = NULL;
		_tmp9_ = search_text;
		_tmp10_ = g_strdup (_tmp9_);
		_g_free0 (pattern);
		pattern = _tmp10_;
	} else {
		const gchar* _tmp11_ = NULL;
		gchar* _tmp12_ = NULL;
		_tmp11_ = search_text;
		_tmp12_ = g_regex_escape_string (_tmp11_, -1);
		_g_free0 (pattern);
		pattern = _tmp12_;
	}
	_tmp13_ = self->priv->entire_word_checkbutton;
	_tmp14_ = gtk_toggle_button_get_active (_tmp13_);
	_tmp15_ = _tmp14_;
	if (_tmp15_) {
		const gchar* _tmp16_ = NULL;
		gchar* _tmp17_ = NULL;
		gchar* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		_tmp16_ = pattern;
		_tmp17_ = g_strconcat ("\\b", _tmp16_, NULL);
		_tmp18_ = _tmp17_;
		_tmp19_ = g_strconcat (_tmp18_, "\\b", NULL);
		_g_free0 (pattern);
		pattern = _tmp19_;
		_g_free0 (_tmp18_);
	}
	_tmp21_ = caseless;
	_tmp22_ = self->priv->regex_caseless;
	if (_tmp21_ == _tmp22_) {
		const gchar* _tmp23_ = NULL;
		const gchar* _tmp24_ = NULL;
		_tmp23_ = pattern;
		_tmp24_ = self->priv->regex_pattern;
		_tmp20_ = g_strcmp0 (_tmp23_, _tmp24_) == 0;
	} else {
		_tmp20_ = FALSE;
	}
	if (_tmp20_) {
		_vte_regex_unref0 (regex);
		_g_regex_unref0 (gregex);
		_g_free0 (pattern);
		_g_free0 (search_text);
		return;
	}
	_g_free0 (self->priv->regex_pattern);
	self->priv->regex_pattern = NULL;
	_tmp25_ = caseless;
	self->priv->regex_caseless = _tmp25_;
	_tmp26_ = search_text;
	_tmp27_ = strlen (_tmp26_);
	_tmp28_ = _tmp27_;
	if (_tmp28_ != 0) {
		{
			gboolean _tmp29_ = FALSE;
			const gchar* _tmp54_ = NULL;
			gchar* _tmp55_ = NULL;
			GtkSearchEntry* _tmp56_ = NULL;
			_tmp29_ = test_app_options_no_pcre;
			if (!_tmp29_) {
				guint32 flags = 0U;
				gboolean _tmp30_ = FALSE;
				VteRegex* _tmp32_ = NULL;
				const gchar* _tmp33_ = NULL;
				const gchar* _tmp34_ = NULL;
				gint _tmp35_ = 0;
				gint _tmp36_ = 0;
				guint32 _tmp37_ = 0U;
				VteRegex* _tmp38_ = NULL;
				VteRegex* _tmp39_ = NULL;
				flags = (guint32) 0x40080400U;
				_tmp30_ = caseless;
				if (_tmp30_) {
					guint32 _tmp31_ = 0U;
					_tmp31_ = flags;
					flags = _tmp31_ | 0x00000008U;
				}
				_tmp33_ = pattern;
				_tmp34_ = pattern;
				_tmp35_ = strlen (_tmp34_);
				_tmp36_ = _tmp35_;
				_tmp37_ = flags;
				_tmp38_ = vte_regex_new_for_search (_tmp33_, (gssize) _tmp36_, _tmp37_, &_inner_error_);
				_tmp32_ = _tmp38_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					goto __catch0_g_error;
				}
				_tmp39_ = _tmp32_;
				_tmp32_ = NULL;
				_vte_regex_unref0 (regex);
				regex = _tmp39_;
				{
					VteRegex* _tmp40_ = NULL;
					VteRegex* _tmp41_ = NULL;
					_tmp40_ = regex;
					vte_regex_jit (_tmp40_, (guint32) 0x00000001U, &_inner_error_);
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						goto __catch1_g_error;
					}
					_tmp41_ = regex;
					vte_regex_jit (_tmp41_, (guint32) 0x00000002U, &_inner_error_);
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						goto __catch1_g_error;
					}
				}
				goto __finally1;
				__catch1_g_error:
				{
					GError* e = NULL;
					GError* _tmp42_ = NULL;
					gint _tmp43_ = 0;
					e = _inner_error_;
					_inner_error_ = NULL;
					_tmp42_ = e;
					_tmp43_ = _tmp42_->code;
					if (_tmp43_ != -45) {
						const gchar* _tmp44_ = NULL;
						GError* _tmp45_ = NULL;
						const gchar* _tmp46_ = NULL;
						_tmp44_ = pattern;
						_tmp45_ = e;
						_tmp46_ = _tmp45_->message;
						g_printerr ("JITing regex \"%s\" failed: %s\n", _tmp44_, _tmp46_);
					}
					_g_error_free0 (e);
				}
				__finally1:
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_vte_regex_unref0 (_tmp32_);
					goto __catch0_g_error;
				}
				_vte_regex_unref0 (_tmp32_);
			} else {
				GRegexCompileFlags flags = 0;
				gboolean _tmp47_ = FALSE;
				GRegex* _tmp49_ = NULL;
				const gchar* _tmp50_ = NULL;
				GRegexCompileFlags _tmp51_ = 0;
				GRegex* _tmp52_ = NULL;
				GRegex* _tmp53_ = NULL;
				flags = G_REGEX_OPTIMIZE | G_REGEX_MULTILINE;
				_tmp47_ = caseless;
				if (_tmp47_) {
					GRegexCompileFlags _tmp48_ = 0;
					_tmp48_ = flags;
					flags = _tmp48_ | G_REGEX_CASELESS;
				}
				_tmp50_ = pattern;
				_tmp51_ = flags;
				_tmp52_ = g_regex_new (_tmp50_, _tmp51_, 0, &_inner_error_);
				_tmp49_ = _tmp52_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					goto __catch0_g_error;
				}
				_tmp53_ = _tmp49_;
				_tmp49_ = NULL;
				_g_regex_unref0 (gregex);
				gregex = _tmp53_;
				_g_regex_unref0 (_tmp49_);
			}
			_tmp54_ = pattern;
			_tmp55_ = g_strdup (_tmp54_);
			_g_free0 (self->priv->regex_pattern);
			self->priv->regex_pattern = _tmp55_;
			_tmp56_ = self->priv->search_entry;
			gtk_widget_set_tooltip_text ((GtkWidget*) _tmp56_, NULL);
		}
		goto __finally0;
		__catch0_g_error:
		{
			GError* e = NULL;
			GtkSearchEntry* _tmp57_ = NULL;
			GError* _tmp58_ = NULL;
			const gchar* _tmp59_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_vte_regex_unref0 (regex);
			regex = NULL;
			_g_regex_unref0 (gregex);
			gregex = NULL;
			_tmp57_ = self->priv->search_entry;
			_tmp58_ = e;
			_tmp59_ = _tmp58_->message;
			gtk_widget_set_tooltip_text ((GtkWidget*) _tmp57_, _tmp59_);
			_g_error_free0 (e);
		}
		__finally0:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_vte_regex_unref0 (regex);
			_g_regex_unref0 (gregex);
			_g_free0 (pattern);
			_g_free0 (search_text);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	} else {
		GtkSearchEntry* _tmp60_ = NULL;
		_vte_regex_unref0 (regex);
		regex = NULL;
		_g_regex_unref0 (gregex);
		gregex = NULL;
		_tmp60_ = self->priv->search_entry;
		gtk_widget_set_tooltip_text ((GtkWidget*) _tmp60_, NULL);
	}
	_tmp61_ = test_app_options_no_pcre;
	if (!_tmp61_) {
		VteRegex* _tmp62_ = NULL;
		VteTerminal* _tmp63_ = NULL;
		VteRegex* _tmp64_ = NULL;
		_tmp62_ = regex;
		self->priv->has_regex = _tmp62_ != NULL;
		_tmp63_ = self->priv->_terminal;
		_tmp64_ = regex;
		vte_terminal_search_set_regex (_tmp63_, _tmp64_, (guint32) 0);
	} else {
		GRegex* _tmp65_ = NULL;
		VteTerminal* _tmp66_ = NULL;
		GRegex* _tmp67_ = NULL;
		_tmp65_ = gregex;
		self->priv->has_regex = _tmp65_ != NULL;
		_tmp66_ = self->priv->_terminal;
		_tmp67_ = gregex;
		vte_terminal_search_set_gregex (_tmp66_, _tmp67_, 0);
	}
	test_search_popover_update_sensitivity (self);
	_vte_regex_unref0 (regex);
	_g_regex_unref0 (gregex);
	_g_free0 (pattern);
	_g_free0 (search_text);
}


static void test_search_popover_search (TestSearchPopover* self, gboolean backward) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = test_search_popover_have_regex (self);
	if (!_tmp0_) {
		return;
	}
	_tmp1_ = backward;
	if (_tmp1_) {
		VteTerminal* _tmp2_ = NULL;
		_tmp2_ = self->priv->_terminal;
		vte_terminal_search_find_previous (_tmp2_);
	} else {
		VteTerminal* _tmp3_ = NULL;
		_tmp3_ = self->priv->_terminal;
		vte_terminal_search_find_next (_tmp3_);
	}
}


VteTerminal* test_search_popover_get_terminal (TestSearchPopover* self) {
	VteTerminal* result;
	VteTerminal* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_terminal;
	result = _tmp0_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void test_search_popover_set_terminal (TestSearchPopover* self, VteTerminal* value) {
	VteTerminal* _tmp0_ = NULL;
	VteTerminal* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_terminal);
	self->priv->_terminal = _tmp1_;
	g_object_notify ((GObject *) self, "terminal");
}


static void test_search_popover_class_init (TestSearchPopoverClass * klass) {
	gint TestSearchPopover_private_offset;
	test_search_popover_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (TestSearchPopoverPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_test_search_popover_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_test_search_popover_set_property;
	G_OBJECT_CLASS (klass)->finalize = test_search_popover_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), TEST_SEARCH_POPOVER_TERMINAL, g_param_spec_object ("terminal", "terminal", "terminal", vte_terminal_get_type (), G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	TestSearchPopover_private_offset = g_type_class_get_instance_private_offset (klass);
	gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass), "/org/gnome/vte/test/app/ui/search-popover.ui");
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "search_entry", FALSE, TestSearchPopover_private_offset + G_STRUCT_OFFSET (TestSearchPopoverPrivate, search_entry));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "search_prev_button", FALSE, TestSearchPopover_private_offset + G_STRUCT_OFFSET (TestSearchPopoverPrivate, search_prev_button));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "search_next_button", FALSE, TestSearchPopover_private_offset + G_STRUCT_OFFSET (TestSearchPopoverPrivate, search_next_button));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "close_button", FALSE, TestSearchPopover_private_offset + G_STRUCT_OFFSET (TestSearchPopoverPrivate, close_button));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "match_case_checkbutton", FALSE, TestSearchPopover_private_offset + G_STRUCT_OFFSET (TestSearchPopoverPrivate, match_case_checkbutton));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "entire_word_checkbutton", FALSE, TestSearchPopover_private_offset + G_STRUCT_OFFSET (TestSearchPopoverPrivate, entire_word_checkbutton));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "regex_checkbutton", FALSE, TestSearchPopover_private_offset + G_STRUCT_OFFSET (TestSearchPopoverPrivate, regex_checkbutton));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "wrap_around_checkbutton", FALSE, TestSearchPopover_private_offset + G_STRUCT_OFFSET (TestSearchPopoverPrivate, wrap_around_checkbutton));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "reveal_button", FALSE, TestSearchPopover_private_offset + G_STRUCT_OFFSET (TestSearchPopoverPrivate, reveal_button));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "revealer", FALSE, TestSearchPopover_private_offset + G_STRUCT_OFFSET (TestSearchPopoverPrivate, revealer));
}


static void test_search_popover_instance_init (TestSearchPopover * self) {
	self->priv = TEST_SEARCH_POPOVER_GET_PRIVATE (self);
	self->priv->regex_caseless = FALSE;
	self->priv->regex_pattern = NULL;
	self->priv->has_regex = FALSE;
	gtk_widget_init_template (GTK_WIDGET (self));
}


static void test_search_popover_finalize (GObject* obj) {
	TestSearchPopover * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TEST_TYPE_SEARCH_POPOVER, TestSearchPopover);
	_g_object_unref0 (self->priv->_terminal);
	_g_object_unref0 (self->priv->search_entry);
	_g_object_unref0 (self->priv->search_prev_button);
	_g_object_unref0 (self->priv->search_next_button);
	_g_object_unref0 (self->priv->close_button);
	_g_object_unref0 (self->priv->match_case_checkbutton);
	_g_object_unref0 (self->priv->entire_word_checkbutton);
	_g_object_unref0 (self->priv->regex_checkbutton);
	_g_object_unref0 (self->priv->wrap_around_checkbutton);
	_g_object_unref0 (self->priv->reveal_button);
	_g_object_unref0 (self->priv->revealer);
	_g_free0 (self->priv->regex_pattern);
	G_OBJECT_CLASS (test_search_popover_parent_class)->finalize (obj);
}


GType test_search_popover_get_type (void) {
	static volatile gsize test_search_popover_type_id__volatile = 0;
	if (g_once_init_enter (&test_search_popover_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TestSearchPopoverClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) test_search_popover_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TestSearchPopover), 0, (GInstanceInitFunc) test_search_popover_instance_init, NULL };
		GType test_search_popover_type_id;
		test_search_popover_type_id = g_type_register_static (gtk_popover_get_type (), "TestSearchPopover", &g_define_type_info, 0);
		g_once_init_leave (&test_search_popover_type_id__volatile, test_search_popover_type_id);
	}
	return test_search_popover_type_id__volatile;
}


static void _vala_test_search_popover_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	TestSearchPopover * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TEST_TYPE_SEARCH_POPOVER, TestSearchPopover);
	switch (property_id) {
		case TEST_SEARCH_POPOVER_TERMINAL:
		g_value_set_object (value, test_search_popover_get_terminal (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_test_search_popover_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	TestSearchPopover * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TEST_TYPE_SEARCH_POPOVER, TestSearchPopover);
	switch (property_id) {
		case TEST_SEARCH_POPOVER_TERMINAL:
		test_search_popover_set_terminal (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _test_window_action_copy_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	test_window_action_copy_cb ((TestWindow*) self);
}


static void _test_window_action_copy_match_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	test_window_action_copy_match_cb ((TestWindow*) self, action, parameter);
}


static void _test_window_action_paste_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	test_window_action_paste_cb ((TestWindow*) self);
}


static void _test_window_action_reset_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	test_window_action_reset_cb ((TestWindow*) self, action, parameter);
}


static void _test_window_action_find_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	test_window_action_find_cb ((TestWindow*) self);
}


static void _test_window_action_quit_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	test_window_action_quit_cb ((TestWindow*) self);
}


static void __lambda8_ (TestWindow* self, GObject* obj, GParamSpec* pspec) {
	GAction* a = NULL;
	GObject* _tmp0_ = NULL;
	GAction* _tmp1_ = NULL;
	GtkWidget* _tmp2_ = NULL;
	GVariant* _tmp3_ = NULL;
	GVariant* _tmp4_ = NULL;
	GVariant* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	g_return_if_fail (obj != NULL);
	g_return_if_fail (pspec != NULL);
	_tmp0_ = obj;
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp0_, g_action_get_type (), GAction));
	a = _tmp1_;
	_tmp2_ = self->priv->readonly_emblem;
	_tmp3_ = g_action_get_state (a);
	_tmp4_ = _tmp3_;
	_tmp5_ = _tmp4_;
	_tmp6_ = g_variant_get_boolean (_tmp5_);
	gtk_widget_set_visible (_tmp2_, !_tmp6_);
	_g_variant_unref0 (_tmp5_);
	_g_object_unref0 (a);
}


static void ___lambda8__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	__lambda8_ ((TestWindow*) self, _sender, pspec);
}


static void __lambda9_ (TestWindow* self) {
	GtkToggleButton* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	_tmp0_ = self->priv->find_button;
	_tmp1_ = gtk_toggle_button_get_active (_tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		GtkToggleButton* _tmp3_ = NULL;
		_tmp3_ = self->priv->find_button;
		gtk_toggle_button_set_active (_tmp3_, FALSE);
	}
}


static void ___lambda9__gtk_popover_closed (GtkPopover* _sender, gpointer self) {
	__lambda9_ ((TestWindow*) self);
}


static void __lambda10_ (TestWindow* self) {
	gboolean active = FALSE;
	GtkToggleButton* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	TestSearchPopover* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	_tmp0_ = self->priv->find_button;
	_tmp1_ = gtk_toggle_button_get_active (_tmp0_);
	_tmp2_ = _tmp1_;
	active = _tmp2_;
	_tmp3_ = self->priv->search_popover;
	_tmp4_ = gtk_widget_get_visible ((GtkWidget*) _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = active;
	if (_tmp5_ != _tmp6_) {
		TestSearchPopover* _tmp7_ = NULL;
		gboolean _tmp8_ = FALSE;
		_tmp7_ = self->priv->search_popover;
		_tmp8_ = active;
		gtk_widget_set_visible ((GtkWidget*) _tmp7_, _tmp8_);
	}
}


static void ___lambda10__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	__lambda10_ ((TestWindow*) self);
}


static void _test_window_clipboard_owner_change_cb_gtk_clipboard_owner_change (GtkClipboard* _sender, GdkEvent* p0, gpointer self) {
	test_window_clipboard_owner_change_cb ((TestWindow*) self, _sender, p0);
}


static gboolean _test_window_popup_menu_cb_gtk_widget_popup_menu (GtkWidget* _sender, gpointer self) {
	gboolean result;
	result = test_window_popup_menu_cb ((TestWindow*) self);
	return result;
}


static gboolean _test_window_button_press_event_cb_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = test_window_button_press_event_cb ((TestWindow*) self, _sender, event);
	return result;
}


static void _test_window_char_size_changed_cb_vte_terminal_char_size_changed (VteTerminal* _sender, guint char_width, guint char_height, gpointer self) {
	test_window_char_size_changed_cb ((TestWindow*) self, _sender, char_width, char_height);
}


static void _test_window_child_exited_cb_vte_terminal_child_exited (VteTerminal* _sender, gint status, gpointer self) {
	test_window_child_exited_cb ((TestWindow*) self, _sender, status);
}


static void _test_window_decrease_font_size_cb_vte_terminal_decrease_font_size (VteTerminal* _sender, gpointer self) {
	test_window_decrease_font_size_cb ((TestWindow*) self, _sender);
}


static void _test_window_deiconify_window_cb_vte_terminal_deiconify_window (VteTerminal* _sender, gpointer self) {
	test_window_deiconify_window_cb ((TestWindow*) self, _sender);
}


static void _test_window_icon_title_changed_cb_vte_terminal_icon_title_changed (VteTerminal* _sender, gpointer self) {
	test_window_icon_title_changed_cb ((TestWindow*) self, _sender);
}


static void _test_window_iconify_window_cb_vte_terminal_iconify_window (VteTerminal* _sender, gpointer self) {
	test_window_iconify_window_cb ((TestWindow*) self, _sender);
}


static void _test_window_increase_font_size_cb_vte_terminal_increase_font_size (VteTerminal* _sender, gpointer self) {
	test_window_increase_font_size_cb ((TestWindow*) self, _sender);
}


static void _test_window_lower_window_cb_vte_terminal_lower_window (VteTerminal* _sender, gpointer self) {
	test_window_lower_window_cb ((TestWindow*) self, _sender);
}


static void _test_window_maximize_window_cb_vte_terminal_maximize_window (VteTerminal* _sender, gpointer self) {
	test_window_maximize_window_cb ((TestWindow*) self, _sender);
}


static void _test_window_move_window_cb_vte_terminal_move_window (VteTerminal* _sender, guint x, guint y, gpointer self) {
	test_window_move_window_cb ((TestWindow*) self, _sender, x, y);
}


static void _test_window_raise_window_cb_vte_terminal_raise_window (VteTerminal* _sender, gpointer self) {
	test_window_raise_window_cb ((TestWindow*) self, _sender);
}


static void _test_window_realize_cb_gtk_widget_realize (GtkWidget* _sender, gpointer self) {
	test_window_realize_cb ((TestWindow*) self, _sender);
}


static void _test_window_refresh_window_cb_vte_terminal_refresh_window (VteTerminal* _sender, gpointer self) {
	test_window_refresh_window_cb ((TestWindow*) self, _sender);
}


static void _test_window_resize_window_cb_vte_terminal_resize_window (VteTerminal* _sender, guint width, guint height, gpointer self) {
	test_window_resize_window_cb ((TestWindow*) self, _sender, width, height);
}


static void _test_window_restore_window_cb_vte_terminal_restore_window (VteTerminal* _sender, gpointer self) {
	test_window_restore_window_cb ((TestWindow*) self, _sender);
}


static void _test_window_selection_changed_cb_vte_terminal_selection_changed (VteTerminal* _sender, gpointer self) {
	test_window_selection_changed_cb ((TestWindow*) self, _sender);
}


static void _test_window_window_title_changed_cb_vte_terminal_window_title_changed (VteTerminal* _sender, gpointer self) {
	test_window_window_title_changed_cb ((TestWindow*) self, _sender);
}


static void _test_window_notify_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	test_window_notify_cb ((TestWindow*) self, _sender, pspec);
}


static void _vala_PangoFontDescription_free (PangoFontDescription* self) {
	g_boxed_free (pango_font_description_get_type (), self);
}


TestWindow* test_window_construct (GType object_type, TestApp* app) {
	TestWindow * self = NULL;
	TestApp* _tmp0_ = NULL;
	VteTerminal* _tmp1_ = NULL;
	gint margin = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	GtkScrollbar* _tmp9_ = NULL;
	VteTerminal* _tmp10_ = NULL;
	GtkAdjustment* _tmp11_ = NULL;
	GPropertyAction* action = NULL;
	VteTerminal* _tmp12_ = NULL;
	GPropertyAction* _tmp13_ = NULL;
	GPropertyAction* _tmp14_ = NULL;
	GPropertyAction* _tmp15_ = NULL;
	VteTerminal* _tmp16_ = NULL;
	GtkToggleButton* _tmp17_ = NULL;
	TestSearchPopover* _tmp18_ = NULL;
	TestSearchPopover* _tmp19_ = NULL;
	GtkToggleButton* _tmp20_ = NULL;
	GMenu* menu = NULL;
	GMenu* _tmp21_ = NULL;
	GMenu* section = NULL;
	GMenu* _tmp22_ = NULL;
	GMenu* _tmp23_ = NULL;
	GMenu* _tmp24_ = NULL;
	GMenu* _tmp25_ = NULL;
	GMenu* _tmp26_ = NULL;
	GMenu* _tmp27_ = NULL;
	GMenu* _tmp28_ = NULL;
	GMenu* _tmp29_ = NULL;
	GMenu* _tmp30_ = NULL;
	GMenu* _tmp31_ = NULL;
	GMenu* _tmp32_ = NULL;
	GMenu* _tmp33_ = NULL;
	GMenu* _tmp34_ = NULL;
	GMenu* _tmp35_ = NULL;
	GMenu* _tmp36_ = NULL;
	GMenu* _tmp37_ = NULL;
	GtkMenuButton* _tmp38_ = NULL;
	GMenu* _tmp39_ = NULL;
	GtkClipboard* _tmp40_ = NULL;
	GtkClipboard* _tmp41_ = NULL;
	GtkClipboard* _tmp42_ = NULL;
	gint _tmp43_ = 0;
	VteTerminal* _tmp52_ = NULL;
	VteTerminal* _tmp53_ = NULL;
	VteTerminal* _tmp54_ = NULL;
	VteTerminal* _tmp55_ = NULL;
	VteTerminal* _tmp56_ = NULL;
	VteTerminal* _tmp57_ = NULL;
	VteTerminal* _tmp58_ = NULL;
	VteTerminal* _tmp59_ = NULL;
	VteTerminal* _tmp60_ = NULL;
	VteTerminal* _tmp61_ = NULL;
	VteTerminal* _tmp62_ = NULL;
	VteTerminal* _tmp63_ = NULL;
	VteTerminal* _tmp64_ = NULL;
	VteTerminal* _tmp65_ = NULL;
	VteTerminal* _tmp66_ = NULL;
	VteTerminal* _tmp67_ = NULL;
	VteTerminal* _tmp68_ = NULL;
	VteTerminal* _tmp69_ = NULL;
	VteTerminal* _tmp70_ = NULL;
	gboolean _tmp71_ = FALSE;
	gboolean _tmp73_ = FALSE;
	const gchar* _tmp75_ = NULL;
	const gchar* _tmp80_ = NULL;
	VteTerminal* _tmp83_ = NULL;
	gboolean _tmp84_ = FALSE;
	VteTerminal* _tmp85_ = NULL;
	gint _tmp86_ = 0;
	VteTerminal* _tmp87_ = NULL;
	VteCursorBlinkMode _tmp88_ = 0;
	VteTerminal* _tmp89_ = NULL;
	VteCursorShape _tmp90_ = 0;
	VteTerminal* _tmp91_ = NULL;
	VteTerminal* _tmp92_ = NULL;
	gboolean _tmp93_ = FALSE;
	VteTerminal* _tmp94_ = NULL;
	VteTerminal* _tmp95_ = NULL;
	VteTerminal* _tmp96_ = NULL;
	gint _tmp97_ = 0;
	const gchar* _tmp98_ = NULL;
	VteTerminal* _tmp103_ = NULL;
	GdkRGBA _tmp104_ = {0};
	GdkRGBA _tmp105_ = {0};
	VteTerminal* _tmp106_ = NULL;
	GdkRGBA* _tmp107_ = NULL;
	GdkRGBA* _tmp108_ = NULL;
	VteTerminal* _tmp109_ = NULL;
	GdkRGBA* _tmp110_ = NULL;
	GdkRGBA* _tmp111_ = NULL;
	VteTerminal* _tmp112_ = NULL;
	GdkRGBA* _tmp113_ = NULL;
	GdkRGBA* _tmp114_ = NULL;
	VteTerminal* _tmp115_ = NULL;
	GdkRGBA* _tmp116_ = NULL;
	GdkRGBA* _tmp117_ = NULL;
	gboolean _tmp118_ = FALSE;
	gchar** _tmp120_ = NULL;
	gint _tmp120__length1 = 0;
	GtkBox* _tmp122_ = NULL;
	VteTerminal* _tmp123_ = NULL;
	VteTerminal* _tmp124_ = NULL;
	VteTerminal* _tmp125_ = NULL;
	gboolean _tmp126_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (app != NULL, NULL);
	_tmp0_ = app;
	self = (TestWindow*) g_object_new (object_type, "application", _tmp0_, NULL);
	_tmp1_ = (VteTerminal*) vte_terminal_new ();
	g_object_ref_sink (_tmp1_);
	_g_object_unref0 (self->priv->terminal);
	self->priv->terminal = _tmp1_;
	_tmp2_ = test_app_options_extra_margin;
	margin = _tmp2_;
	_tmp3_ = margin;
	if (_tmp3_ > 0) {
		VteTerminal* _tmp4_ = NULL;
		VteTerminal* _tmp5_ = NULL;
		VteTerminal* _tmp6_ = NULL;
		VteTerminal* _tmp7_ = NULL;
		gint _tmp8_ = 0;
		_tmp4_ = self->priv->terminal;
		_tmp5_ = self->priv->terminal;
		_tmp6_ = self->priv->terminal;
		_tmp7_ = self->priv->terminal;
		_tmp8_ = margin;
		gtk_widget_set_margin_bottom ((GtkWidget*) _tmp7_, _tmp8_);
		gtk_widget_set_margin_top ((GtkWidget*) _tmp6_, _tmp8_);
		gtk_widget_set_margin_end ((GtkWidget*) _tmp5_, _tmp8_);
		gtk_widget_set_margin_start ((GtkWidget*) _tmp4_, _tmp8_);
	}
	_tmp9_ = self->priv->scrollbar;
	_tmp10_ = self->priv->terminal;
	_tmp11_ = gtk_scrollable_get_vadjustment ((GtkScrollable*) _tmp10_);
	gtk_range_set_adjustment ((GtkRange*) _tmp9_, _tmp11_);
	g_action_map_add_action_entries ((GActionMap*) self, TEST_WINDOW_action_entries, G_N_ELEMENTS (TEST_WINDOW_action_entries), self);
	_tmp12_ = self->priv->terminal;
	_tmp13_ = g_property_action_new ("input-enabled", (GObject*) _tmp12_, "input-enabled");
	action = _tmp13_;
	_tmp14_ = action;
	g_action_map_add_action ((GActionMap*) self, (GAction*) _tmp14_);
	_tmp15_ = action;
	g_signal_connect_object ((GObject*) _tmp15_, "notify::state", (GCallback) ___lambda8__g_object_notify, self, 0);
	_tmp16_ = self->priv->terminal;
	_tmp17_ = self->priv->find_button;
	_tmp18_ = test_search_popover_new (_tmp16_, (GtkWidget*) _tmp17_);
	g_object_ref_sink (_tmp18_);
	_g_object_unref0 (self->priv->search_popover);
	self->priv->search_popover = _tmp18_;
	_tmp19_ = self->priv->search_popover;
	g_signal_connect_object ((GtkPopover*) _tmp19_, "closed", (GCallback) ___lambda9__gtk_popover_closed, self, 0);
	_tmp20_ = self->priv->find_button;
	g_signal_connect_object (_tmp20_, "toggled", (GCallback) ___lambda10__gtk_toggle_button_toggled, self, 0);
	_tmp21_ = g_menu_new ();
	menu = _tmp21_;
	_tmp22_ = g_menu_new ();
	section = _tmp22_;
	_tmp23_ = section;
	g_menu_append (_tmp23_, "_Copy", "win.copy");
	_tmp24_ = section;
	g_menu_append (_tmp24_, "_Paste", "win.paste");
	_tmp25_ = section;
	g_menu_append (_tmp25_, "_Find…", "win.find");
	_tmp26_ = menu;
	_tmp27_ = section;
	g_menu_append_section (_tmp26_, NULL, (GMenuModel*) _tmp27_);
	_tmp28_ = g_menu_new ();
	_g_object_unref0 (section);
	section = _tmp28_;
	_tmp29_ = section;
	g_menu_append (_tmp29_, "_Reset", "win.reset(false)");
	_tmp30_ = section;
	g_menu_append (_tmp30_, "Reset and C_lear", "win.reset(true)");
	_tmp31_ = section;
	g_menu_append (_tmp31_, "_Input enabled", "win.input-enabled");
	_tmp32_ = menu;
	_tmp33_ = section;
	g_menu_append_section (_tmp32_, NULL, (GMenuModel*) _tmp33_);
	_tmp34_ = g_menu_new ();
	_g_object_unref0 (section);
	section = _tmp34_;
	_tmp35_ = section;
	g_menu_append (_tmp35_, "_Quit", "win.quit");
	_tmp36_ = menu;
	_tmp37_ = section;
	g_menu_append_section (_tmp36_, NULL, (GMenuModel*) _tmp37_);
	_tmp38_ = self->priv->gear_button;
	_tmp39_ = menu;
	gtk_menu_button_set_menu_model (_tmp38_, (GMenuModel*) _tmp39_);
	_tmp40_ = gtk_widget_get_clipboard ((GtkWidget*) self, GDK_SELECTION_CLIPBOARD);
	_tmp41_ = _g_object_ref0 (_tmp40_);
	_g_object_unref0 (self->priv->clipboard);
	self->priv->clipboard = _tmp41_;
	_tmp42_ = self->priv->clipboard;
	g_signal_connect_object (_tmp42_, "owner-change", (GCallback) _test_window_clipboard_owner_change_cb_gtk_clipboard_owner_change, self, 0);
	gtk_window_set_title ((GtkWindow*) self, "Terminal");
	_tmp43_ = test_app_options_transparency_percent;
	if (_tmp43_ != 0) {
		gboolean _tmp44_ = FALSE;
		_tmp44_ = test_app_options_no_argb_visual;
		if (!_tmp44_) {
			GdkScreen* screen = NULL;
			GdkScreen* _tmp45_ = NULL;
			GdkScreen* _tmp46_ = NULL;
			GdkVisual* visual = NULL;
			GdkScreen* _tmp47_ = NULL;
			GdkVisual* _tmp48_ = NULL;
			GdkVisual* _tmp49_ = NULL;
			GdkVisual* _tmp50_ = NULL;
			_tmp45_ = gtk_window_get_screen ((GtkWindow*) self);
			_tmp46_ = _g_object_ref0 (_tmp45_);
			screen = _tmp46_;
			_tmp47_ = screen;
			_tmp48_ = gdk_screen_get_rgba_visual (_tmp47_);
			_tmp49_ = _g_object_ref0 (_tmp48_);
			visual = _tmp49_;
			_tmp50_ = visual;
			if (_tmp50_ != NULL) {
				GdkVisual* _tmp51_ = NULL;
				_tmp51_ = visual;
				gtk_widget_set_visual ((GtkWidget*) self, _tmp51_);
			}
			_g_object_unref0 (visual);
			_g_object_unref0 (screen);
		}
		gtk_widget_set_app_paintable ((GtkWidget*) self, TRUE);
	}
	_tmp52_ = self->priv->terminal;
	g_signal_connect_object ((GtkWidget*) _tmp52_, "popup-menu", (GCallback) _test_window_popup_menu_cb_gtk_widget_popup_menu, self, 0);
	_tmp53_ = self->priv->terminal;
	g_signal_connect_object ((GtkWidget*) _tmp53_, "button-press-event", (GCallback) _test_window_button_press_event_cb_gtk_widget_button_press_event, self, 0);
	_tmp54_ = self->priv->terminal;
	g_signal_connect_object (_tmp54_, "char-size-changed", (GCallback) _test_window_char_size_changed_cb_vte_terminal_char_size_changed, self, 0);
	_tmp55_ = self->priv->terminal;
	g_signal_connect_object (_tmp55_, "child-exited", (GCallback) _test_window_child_exited_cb_vte_terminal_child_exited, self, 0);
	_tmp56_ = self->priv->terminal;
	g_signal_connect_object (_tmp56_, "decrease-font-size", (GCallback) _test_window_decrease_font_size_cb_vte_terminal_decrease_font_size, self, 0);
	_tmp57_ = self->priv->terminal;
	g_signal_connect_object (_tmp57_, "deiconify-window", (GCallback) _test_window_deiconify_window_cb_vte_terminal_deiconify_window, self, 0);
	_tmp58_ = self->priv->terminal;
	g_signal_connect_object (_tmp58_, "icon-title-changed", (GCallback) _test_window_icon_title_changed_cb_vte_terminal_icon_title_changed, self, 0);
	_tmp59_ = self->priv->terminal;
	g_signal_connect_object (_tmp59_, "iconify-window", (GCallback) _test_window_iconify_window_cb_vte_terminal_iconify_window, self, 0);
	_tmp60_ = self->priv->terminal;
	g_signal_connect_object (_tmp60_, "increase-font-size", (GCallback) _test_window_increase_font_size_cb_vte_terminal_increase_font_size, self, 0);
	_tmp61_ = self->priv->terminal;
	g_signal_connect_object (_tmp61_, "lower-window", (GCallback) _test_window_lower_window_cb_vte_terminal_lower_window, self, 0);
	_tmp62_ = self->priv->terminal;
	g_signal_connect_object (_tmp62_, "maximize-window", (GCallback) _test_window_maximize_window_cb_vte_terminal_maximize_window, self, 0);
	_tmp63_ = self->priv->terminal;
	g_signal_connect_object (_tmp63_, "move-window", (GCallback) _test_window_move_window_cb_vte_terminal_move_window, self, 0);
	_tmp64_ = self->priv->terminal;
	g_signal_connect_object (_tmp64_, "raise-window", (GCallback) _test_window_raise_window_cb_vte_terminal_raise_window, self, 0);
	_tmp65_ = self->priv->terminal;
	g_signal_connect_object ((GtkWidget*) _tmp65_, "realize", (GCallback) _test_window_realize_cb_gtk_widget_realize, self, 0);
	_tmp66_ = self->priv->terminal;
	g_signal_connect_object (_tmp66_, "refresh-window", (GCallback) _test_window_refresh_window_cb_vte_terminal_refresh_window, self, 0);
	_tmp67_ = self->priv->terminal;
	g_signal_connect_object (_tmp67_, "resize-window", (GCallback) _test_window_resize_window_cb_vte_terminal_resize_window, self, 0);
	_tmp68_ = self->priv->terminal;
	g_signal_connect_object (_tmp68_, "restore-window", (GCallback) _test_window_restore_window_cb_vte_terminal_restore_window, self, 0);
	_tmp69_ = self->priv->terminal;
	g_signal_connect_object (_tmp69_, "selection-changed", (GCallback) _test_window_selection_changed_cb_vte_terminal_selection_changed, self, 0);
	_tmp70_ = self->priv->terminal;
	g_signal_connect_object (_tmp70_, "window-title-changed", (GCallback) _test_window_window_title_changed_cb_vte_terminal_window_title_changed, self, 0);
	_tmp71_ = test_app_options_object_notifications;
	if (_tmp71_) {
		VteTerminal* _tmp72_ = NULL;
		_tmp72_ = self->priv->terminal;
		g_signal_connect_object ((GObject*) _tmp72_, "notify", (GCallback) _test_window_notify_cb_g_object_notify, self, 0);
	}
	_tmp73_ = test_app_options_no_double_buffer;
	if (_tmp73_) {
		VteTerminal* _tmp74_ = NULL;
		_tmp74_ = self->priv->terminal;
		gtk_widget_set_double_buffered ((GtkWidget*) _tmp74_, FALSE);
	}
	_tmp75_ = test_app_options_encoding;
	if (_tmp75_ != NULL) {
		{
			VteTerminal* _tmp76_ = NULL;
			const gchar* _tmp77_ = NULL;
			_tmp76_ = self->priv->terminal;
			_tmp77_ = test_app_options_encoding;
			vte_terminal_set_encoding (_tmp76_, _tmp77_, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch2_g_error;
			}
		}
		goto __finally2;
		__catch2_g_error:
		{
			GError* e = NULL;
			GError* _tmp78_ = NULL;
			const gchar* _tmp79_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp78_ = e;
			_tmp79_ = _tmp78_->message;
			g_printerr ("Failed to set encoding: %s\n", _tmp79_);
			_g_error_free0 (e);
		}
		__finally2:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (section);
			_g_object_unref0 (menu);
			_g_object_unref0 (action);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp80_ = test_app_options_word_char_exceptions;
	if (_tmp80_ != NULL) {
		VteTerminal* _tmp81_ = NULL;
		const gchar* _tmp82_ = NULL;
		_tmp81_ = self->priv->terminal;
		_tmp82_ = test_app_options_word_char_exceptions;
		vte_terminal_set_word_char_exceptions (_tmp81_, _tmp82_);
	}
	_tmp83_ = self->priv->terminal;
	_tmp84_ = test_app_options_audible;
	vte_terminal_set_audible_bell (_tmp83_, _tmp84_);
	_tmp85_ = self->priv->terminal;
	_tmp86_ = test_app_options_get_cjk_ambiguous_width ();
	vte_terminal_set_cjk_ambiguous_width (_tmp85_, _tmp86_);
	_tmp87_ = self->priv->terminal;
	_tmp88_ = test_app_options_get_cursor_blink_mode ();
	vte_terminal_set_cursor_blink_mode (_tmp87_, _tmp88_);
	_tmp89_ = self->priv->terminal;
	_tmp90_ = test_app_options_get_cursor_shape ();
	vte_terminal_set_cursor_shape (_tmp89_, _tmp90_);
	_tmp91_ = self->priv->terminal;
	vte_terminal_set_mouse_autohide (_tmp91_, TRUE);
	_tmp92_ = self->priv->terminal;
	_tmp93_ = test_app_options_no_rewrap;
	vte_terminal_set_rewrap_on_resize (_tmp92_, !_tmp93_);
	_tmp94_ = self->priv->terminal;
	vte_terminal_set_scroll_on_output (_tmp94_, FALSE);
	_tmp95_ = self->priv->terminal;
	vte_terminal_set_scroll_on_keystroke (_tmp95_, TRUE);
	_tmp96_ = self->priv->terminal;
	_tmp97_ = test_app_options_scrollback_lines;
	vte_terminal_set_scrollback_lines (_tmp96_, (glong) _tmp97_);
	_tmp98_ = test_app_options_font_string;
	if (_tmp98_ != NULL) {
		PangoFontDescription* desc = NULL;
		const gchar* _tmp99_ = NULL;
		PangoFontDescription* _tmp100_ = NULL;
		VteTerminal* _tmp101_ = NULL;
		PangoFontDescription* _tmp102_ = NULL;
		_tmp99_ = test_app_options_font_string;
		_tmp100_ = pango_font_description_from_string (_tmp99_);
		desc = _tmp100_;
		_tmp101_ = self->priv->terminal;
		_tmp102_ = desc;
		vte_terminal_set_font (_tmp101_, _tmp102_);
		__vala_PangoFontDescription_free0 (desc);
	}
	_tmp103_ = self->priv->terminal;
	test_app_options_get_color_fg (&_tmp104_);
	test_app_options_get_color_bg (&_tmp105_);
	vte_terminal_set_colors (_tmp103_, &_tmp104_, &_tmp105_, NULL, (gsize) 0);
	_tmp106_ = self->priv->terminal;
	_tmp107_ = test_app_options_get_color_cursor_background ();
	_tmp108_ = _tmp107_;
	vte_terminal_set_color_cursor (_tmp106_, _tmp108_);
	_g_free0 (_tmp108_);
	_tmp109_ = self->priv->terminal;
	_tmp110_ = test_app_options_get_color_cursor_foreground ();
	_tmp111_ = _tmp110_;
	vte_terminal_set_color_cursor_foreground (_tmp109_, _tmp111_);
	_g_free0 (_tmp111_);
	_tmp112_ = self->priv->terminal;
	_tmp113_ = test_app_options_get_color_hl_bg ();
	_tmp114_ = _tmp113_;
	vte_terminal_set_color_highlight (_tmp112_, _tmp114_);
	_g_free0 (_tmp114_);
	_tmp115_ = self->priv->terminal;
	_tmp116_ = test_app_options_get_color_hl_fg ();
	_tmp117_ = _tmp116_;
	vte_terminal_set_color_highlight_foreground (_tmp115_, _tmp117_);
	_g_free0 (_tmp117_);
	_tmp118_ = test_app_options_no_builtin_dingus;
	if (!_tmp118_) {
		gchar** _tmp119_ = NULL;
		gint _tmp119__length1 = 0;
		_tmp119_ = self->priv->builtin_dingus;
		_tmp119__length1 = self->priv->builtin_dingus_length1;
		test_window_add_dingus (self, _tmp119_, _tmp119__length1);
	}
	_tmp120_ = test_app_options_dingus;
	_tmp120__length1 = test_app_options_dingus_length1;
	if (_tmp120_ != NULL) {
		gchar** _tmp121_ = NULL;
		gint _tmp121__length1 = 0;
		_tmp121_ = test_app_options_dingus;
		_tmp121__length1 = test_app_options_dingus_length1;
		test_window_add_dingus (self, _tmp121_, _tmp121__length1);
	}
	_tmp122_ = self->priv->terminal_box;
	_tmp123_ = self->priv->terminal;
	gtk_box_pack_start (_tmp122_, (GtkWidget*) _tmp123_, TRUE, TRUE, (guint) 0);
	_tmp124_ = self->priv->terminal;
	gtk_widget_show ((GtkWidget*) _tmp124_);
	test_window_update_paste_sensitivity (self);
	test_window_update_copy_sensitivity (self);
	_tmp125_ = self->priv->terminal;
	gtk_widget_grab_focus ((GtkWidget*) _tmp125_);
	_tmp126_ = gtk_widget_get_realized ((GtkWidget*) self);
	_vala_assert (!_tmp126_, "!get_realized()");
	_g_object_unref0 (section);
	_g_object_unref0 (menu);
	_g_object_unref0 (action);
	return self;
}


TestWindow* test_window_new (TestApp* app) {
	return test_window_construct (TEST_TYPE_WINDOW, app);
}


static void test_window_add_dingus (TestWindow* self, gchar** dingus, int dingus_length1) {
	static const GdkCursorType cursors[] = {GDK_GUMBY, GDK_HAND1};
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp2_ = 0;
				gchar** _tmp3_ = NULL;
				gint _tmp3__length1 = 0;
				if (!_tmp0_) {
					gint _tmp1_ = 0;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp2_ = i;
				_tmp3_ = dingus;
				_tmp3__length1 = dingus_length1;
				if (!(_tmp2_ < _tmp3__length1)) {
					break;
				}
				{
					gint tag = 0;
					gboolean _tmp4_ = FALSE;
					VteTerminal* _tmp37_ = NULL;
					gint _tmp38_ = 0;
					gint _tmp39_ = 0;
					GdkCursorType _tmp40_ = 0;
					_tmp4_ = test_app_options_no_pcre;
					if (!_tmp4_) {
						VteRegex* regex = NULL;
						VteRegex* _tmp5_ = NULL;
						gchar** _tmp6_ = NULL;
						gint _tmp6__length1 = 0;
						gint _tmp7_ = 0;
						const gchar* _tmp8_ = NULL;
						gchar** _tmp9_ = NULL;
						gint _tmp9__length1 = 0;
						gint _tmp10_ = 0;
						const gchar* _tmp11_ = NULL;
						gint _tmp12_ = 0;
						gint _tmp13_ = 0;
						VteRegex* _tmp14_ = NULL;
						VteRegex* _tmp15_ = NULL;
						VteTerminal* _tmp25_ = NULL;
						VteRegex* _tmp26_ = NULL;
						gint _tmp27_ = 0;
						_tmp6_ = dingus;
						_tmp6__length1 = dingus_length1;
						_tmp7_ = i;
						_tmp8_ = _tmp6_[_tmp7_];
						_tmp9_ = dingus;
						_tmp9__length1 = dingus_length1;
						_tmp10_ = i;
						_tmp11_ = _tmp9_[_tmp10_];
						_tmp12_ = strlen (_tmp11_);
						_tmp13_ = _tmp12_;
						_tmp14_ = vte_regex_new_for_match (_tmp8_, (gssize) _tmp13_, (guint32) 0x40080408U, &_inner_error_);
						_tmp5_ = _tmp14_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							_vte_regex_unref0 (regex);
							goto __catch3_g_error;
						}
						_tmp15_ = _tmp5_;
						_tmp5_ = NULL;
						_vte_regex_unref0 (regex);
						regex = _tmp15_;
						{
							VteRegex* _tmp16_ = NULL;
							VteRegex* _tmp17_ = NULL;
							_tmp16_ = regex;
							vte_regex_jit (_tmp16_, (guint32) 0x00000001U, &_inner_error_);
							if (G_UNLIKELY (_inner_error_ != NULL)) {
								goto __catch4_g_error;
							}
							_tmp17_ = regex;
							vte_regex_jit (_tmp17_, (guint32) 0x00000002U, &_inner_error_);
							if (G_UNLIKELY (_inner_error_ != NULL)) {
								goto __catch4_g_error;
							}
						}
						goto __finally4;
						__catch4_g_error:
						{
							GError* e = NULL;
							GError* _tmp18_ = NULL;
							gint _tmp19_ = 0;
							e = _inner_error_;
							_inner_error_ = NULL;
							_tmp18_ = e;
							_tmp19_ = _tmp18_->code;
							if (_tmp19_ != -45) {
								gchar** _tmp20_ = NULL;
								gint _tmp20__length1 = 0;
								gint _tmp21_ = 0;
								const gchar* _tmp22_ = NULL;
								GError* _tmp23_ = NULL;
								const gchar* _tmp24_ = NULL;
								_tmp20_ = dingus;
								_tmp20__length1 = dingus_length1;
								_tmp21_ = i;
								_tmp22_ = _tmp20_[_tmp21_];
								_tmp23_ = e;
								_tmp24_ = _tmp23_->message;
								g_printerr ("JITing regex \"%s\" failed: %s\n", _tmp22_, _tmp24_);
							}
							_g_error_free0 (e);
						}
						__finally4:
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							_vte_regex_unref0 (_tmp5_);
							_vte_regex_unref0 (regex);
							goto __catch3_g_error;
						}
						_tmp25_ = self->priv->terminal;
						_tmp26_ = regex;
						_tmp27_ = vte_terminal_match_add_regex (_tmp25_, _tmp26_, (guint32) 0);
						tag = _tmp27_;
						_vte_regex_unref0 (_tmp5_);
						_vte_regex_unref0 (regex);
					} else {
						GRegex* regex = NULL;
						GRegex* _tmp28_ = NULL;
						gchar** _tmp29_ = NULL;
						gint _tmp29__length1 = 0;
						gint _tmp30_ = 0;
						const gchar* _tmp31_ = NULL;
						GRegex* _tmp32_ = NULL;
						GRegex* _tmp33_ = NULL;
						VteTerminal* _tmp34_ = NULL;
						GRegex* _tmp35_ = NULL;
						gint _tmp36_ = 0;
						_tmp29_ = dingus;
						_tmp29__length1 = dingus_length1;
						_tmp30_ = i;
						_tmp31_ = _tmp29_[_tmp30_];
						_tmp32_ = g_regex_new (_tmp31_, G_REGEX_OPTIMIZE | G_REGEX_MULTILINE, 0, &_inner_error_);
						_tmp28_ = _tmp32_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							_g_regex_unref0 (regex);
							goto __catch3_g_error;
						}
						_tmp33_ = _tmp28_;
						_tmp28_ = NULL;
						_g_regex_unref0 (regex);
						regex = _tmp33_;
						_tmp34_ = self->priv->terminal;
						_tmp35_ = regex;
						_tmp36_ = vte_terminal_match_add_gregex (_tmp34_, _tmp35_, 0);
						tag = _tmp36_;
						_g_regex_unref0 (_tmp28_);
						_g_regex_unref0 (regex);
					}
					_tmp37_ = self->priv->terminal;
					_tmp38_ = tag;
					_tmp39_ = i;
					_tmp40_ = cursors[_tmp39_ % G_N_ELEMENTS (cursors)];
					vte_terminal_match_set_cursor_type (_tmp37_, _tmp38_, _tmp40_);
				}
				goto __finally3;
				__catch3_g_error:
				{
					GError* e = NULL;
					gchar** _tmp41_ = NULL;
					gint _tmp41__length1 = 0;
					gint _tmp42_ = 0;
					const gchar* _tmp43_ = NULL;
					GError* _tmp44_ = NULL;
					const gchar* _tmp45_ = NULL;
					e = _inner_error_;
					_inner_error_ = NULL;
					_tmp41_ = dingus;
					_tmp41__length1 = dingus_length1;
					_tmp42_ = i;
					_tmp43_ = _tmp41_[_tmp42_];
					_tmp44_ = e;
					_tmp45_ = _tmp44_->message;
					g_printerr ("Failed to compile regex \"%s\": %s\n", _tmp43_, _tmp45_);
					_g_error_free0 (e);
				}
				__finally3:
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	}
}


static void test_window_adjust_font_size (TestWindow* self, gdouble factor) {
	glong columns = 0L;
	VteTerminal* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	glong rows = 0L;
	VteTerminal* _tmp2_ = NULL;
	glong _tmp3_ = 0L;
	VteTerminal* _tmp4_ = NULL;
	VteTerminal* _tmp5_ = NULL;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->terminal;
	_tmp1_ = vte_terminal_get_column_count (_tmp0_);
	columns = _tmp1_;
	_tmp2_ = self->priv->terminal;
	_tmp3_ = vte_terminal_get_row_count (_tmp2_);
	rows = _tmp3_;
	_tmp4_ = self->priv->terminal;
	_tmp5_ = self->priv->terminal;
	_tmp6_ = vte_terminal_get_font_scale (_tmp5_);
	_tmp7_ = factor;
	vte_terminal_set_font_scale (_tmp4_, _tmp6_ * _tmp7_);
	test_window_update_geometry (self);
	gtk_window_resize_to_geometry ((GtkWindow*) self, (gint) columns, (gint) rows);
}


void test_window_apply_geometry (TestWindow* self) {
	VteTerminal* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->terminal;
	gtk_widget_realize ((GtkWidget*) _tmp0_);
	_tmp1_ = test_app_options_geometry;
	if (_tmp1_ != NULL) {
		const gchar* _tmp2_ = NULL;
		gboolean _tmp3_ = FALSE;
		_tmp2_ = test_app_options_geometry;
		_tmp3_ = gtk_window_parse_geometry ((GtkWindow*) self, _tmp2_);
		if (_tmp3_) {
			gint columns = 0;
			gint rows = 0;
			gint _tmp4_ = 0;
			gint _tmp5_ = 0;
			VteTerminal* _tmp6_ = NULL;
			gint _tmp7_ = 0;
			gint _tmp8_ = 0;
			gint _tmp9_ = 0;
			gint _tmp10_ = 0;
			gtk_window_get_default_size ((GtkWindow*) self, &_tmp4_, &_tmp5_);
			columns = _tmp4_;
			rows = _tmp5_;
			_tmp6_ = self->priv->terminal;
			_tmp7_ = columns;
			_tmp8_ = rows;
			vte_terminal_set_size (_tmp6_, (glong) _tmp7_, (glong) _tmp8_);
			_tmp9_ = columns;
			_tmp10_ = rows;
			gtk_window_resize_to_geometry ((GtkWindow*) self, _tmp9_, _tmp10_);
		} else {
			const gchar* _tmp11_ = NULL;
			_tmp11_ = test_app_options_geometry;
			g_printerr ("Failed to parse geometry spec \"%s\"\n", _tmp11_);
		}
	} else {
		VteTerminal* _tmp12_ = NULL;
		glong _tmp13_ = 0L;
		VteTerminal* _tmp14_ = NULL;
		glong _tmp15_ = 0L;
		_tmp12_ = self->priv->terminal;
		_tmp13_ = vte_terminal_get_column_count (_tmp12_);
		_tmp14_ = self->priv->terminal;
		_tmp15_ = vte_terminal_get_row_count (_tmp14_);
		gtk_window_set_default_geometry ((GtkWindow*) self, (gint) _tmp13_, (gint) _tmp15_);
	}
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		TestWindow* self;
		self = _data1_->self;
		_data1_->argv = (_vala_array_free (_data1_->argv, _data1_->argv_length1, (GDestroyNotify) g_free), NULL);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static gboolean __lambda11_ (Block1Data* _data1_) {
	TestWindow* self;
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	self = _data1_->self;
	{
		VteTerminal* _tmp0_ = NULL;
		const gchar* _tmp1_ = NULL;
		gchar** _tmp2_ = NULL;
		gint _tmp2__length1 = 0;
		GPid _tmp3_ = 0;
		GPid _tmp4_ = 0;
		_tmp0_ = self->priv->terminal;
		_tmp1_ = test_app_options_working_directory;
		_tmp2_ = test_app_options_environment;
		_tmp2__length1 = test_app_options_environment_length1;
		vte_terminal_spawn_sync (_tmp0_, VTE_PTY_DEFAULT, _tmp1_, _data1_->argv, _tmp2_, G_SPAWN_SEARCH_PATH, NULL, NULL, &_tmp3_, NULL, &_inner_error_);
		self->priv->child_pid = _tmp3_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch5_g_error;
		}
		_tmp4_ = self->priv->child_pid;
		g_print ("Fork succeeded, PID %d\n", (gint) _tmp4_);
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError* e = NULL;
		GError* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = e;
		_tmp6_ = _tmp5_->message;
		g_printerr ("Failed to fork: %s\n", _tmp6_);
		_g_error_free0 (e);
	}
	__finally5:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		gboolean _tmp7_ = FALSE;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return _tmp7_;
	}
	self->priv->launch_idle_id = (guint) 0;
	result = FALSE;
	return result;
}


static gboolean ___lambda11__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda11_ (self);
	return result;
}


static void test_window_launch_command (TestWindow* self, const gchar* command, GError** error) {
	Block1Data* _data1_;
	const gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gint _tmp2_ = 0;
	guint _tmp3_ = 0U;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (command != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = command;
	g_shell_parse_argv (_tmp0_, &_tmp2_, &_tmp1_, &_inner_error_);
	_data1_->argv = (_vala_array_free (_data1_->argv, _data1_->argv_length1, (GDestroyNotify) g_free), NULL);
	_data1_->argv = _tmp1_;
	_data1_->argv_length1 = _tmp2_;
	_data1_->_argv_size_ = _data1_->argv_length1;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		block1_data_unref (_data1_);
		_data1_ = NULL;
		return;
	}
	_tmp3_ = g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda11__gsource_func, block1_data_ref (_data1_), block1_data_unref);
	self->priv->launch_idle_id = _tmp3_;
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_ = 0L;
	gchar _tmp1_ = '\0';
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


static void test_window_launch_shell (TestWindow* self, GError** error) {
	gchar* shell = NULL;
	gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp7_ = FALSE;
	const gchar* _tmp8_ = NULL;
	const gchar* _tmp12_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = vte_get_user_shell ();
	_g_free0 (shell);
	shell = _tmp0_;
	_tmp2_ = shell;
	if (_tmp2_ == NULL) {
		_tmp1_ = TRUE;
	} else {
		const gchar* _tmp3_ = NULL;
		gchar _tmp4_ = '\0';
		_tmp3_ = shell;
		_tmp4_ = string_get (_tmp3_, (glong) 0);
		_tmp1_ = _tmp4_ == '\0';
	}
	if (_tmp1_) {
		const gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = g_getenv ("SHELL");
		_tmp6_ = g_strdup (_tmp5_);
		_g_free0 (shell);
		shell = _tmp6_;
	}
	_tmp8_ = shell;
	if (_tmp8_ == NULL) {
		_tmp7_ = TRUE;
	} else {
		const gchar* _tmp9_ = NULL;
		gchar _tmp10_ = '\0';
		_tmp9_ = shell;
		_tmp10_ = string_get (_tmp9_, (glong) 0);
		_tmp7_ = _tmp10_ == '\0';
	}
	if (_tmp7_) {
		gchar* _tmp11_ = NULL;
		_tmp11_ = g_strdup ("/bin/sh");
		_g_free0 (shell);
		shell = _tmp11_;
	}
	_tmp12_ = shell;
	test_window_launch_command (self, _tmp12_, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_free0 (shell);
		return;
	}
	_g_free0 (shell);
}


static void test_window_fork (TestWindow* self, GError** error) {
	VtePty* pty = NULL;
	pid_t pid = 0;
	VtePty* _tmp0_ = NULL;
	VtePty* _tmp1_ = NULL;
	VtePty* _tmp2_ = NULL;
	pid_t _tmp3_ = 0;
	pid_t _tmp4_ = 0;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp1_ = vte_pty_new_sync (VTE_PTY_DEFAULT, NULL, &_inner_error_);
	_tmp0_ = _tmp1_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (pty);
		return;
	}
	_tmp2_ = _tmp0_;
	_tmp0_ = NULL;
	_g_object_unref0 (pty);
	pty = _tmp2_;
	_tmp3_ = fork ();
	pid = _tmp3_;
	_tmp4_ = pid;
	switch (_tmp4_) {
		case -1:
		{
			g_printerr ("Error forking: %m");
			break;
		}
		case 0:
		{
			{
				VtePty* _tmp5_ = NULL;
				_tmp5_ = pty;
				vte_pty_child_setup (_tmp5_);
				{
					gint i = 0;
					i = 0;
					{
						gboolean _tmp6_ = FALSE;
						_tmp6_ = TRUE;
						while (TRUE) {
							gint _tmp8_ = 0;
							if (!_tmp6_) {
								gint _tmp7_ = 0;
								_tmp7_ = i;
								i = _tmp7_ + 1;
							}
							_tmp6_ = FALSE;
							_tmp8_ = i;
							switch (_tmp8_ % 3) {
								case 0:
								case 1:
								{
									gint _tmp9_ = 0;
									_tmp9_ = i;
									g_print ("%d\n", _tmp9_);
									break;
								}
								case 2:
								{
									gint _tmp10_ = 0;
									_tmp10_ = i;
									g_printerr ("%d\n", _tmp10_);
									break;
								}
								default:
								break;
							}
							sleep ((guint) 1);
						}
					}
				}
			}
		}
		default:
		{
			VteTerminal* _tmp11_ = NULL;
			VtePty* _tmp12_ = NULL;
			VteTerminal* _tmp13_ = NULL;
			pid_t _tmp14_ = 0;
			pid_t _tmp15_ = 0;
			pid_t _tmp16_ = 0;
			_tmp11_ = self->priv->terminal;
			_tmp12_ = pty;
			vte_terminal_set_pty (_tmp11_, _tmp12_);
			_tmp13_ = self->priv->terminal;
			_tmp14_ = pid;
			vte_terminal_watch_child (_tmp13_, (GPid) _tmp14_);
			_tmp15_ = pid;
			_tmp16_ = getpid ();
			g_print ("Child PID is %d (mine is %d).\n", (gint) _tmp15_, (gint) _tmp16_);
			break;
		}
	}
	_g_object_unref0 (_tmp0_);
	_g_object_unref0 (pty);
}


void test_window_launch (TestWindow* self) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		const gchar* _tmp0_ = NULL;
		_tmp0_ = test_app_options_command;
		if (_tmp0_ != NULL) {
			const gchar* _tmp1_ = NULL;
			_tmp1_ = test_app_options_command;
			test_window_launch_command (self, _tmp1_, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch6_g_error;
			}
		} else {
			gboolean _tmp2_ = FALSE;
			_tmp2_ = test_app_options_no_shell;
			if (!_tmp2_) {
				test_window_launch_shell (self, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					goto __catch6_g_error;
				}
			} else {
				test_window_fork (self, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					goto __catch6_g_error;
				}
			}
		}
	}
	goto __finally6;
	__catch6_g_error:
	{
		GError* e = NULL;
		GError* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = e;
		_tmp4_ = _tmp3_->message;
		g_printerr ("Error: %s\n", _tmp4_);
		_g_error_free0 (e);
	}
	__finally6:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void test_window_update_copy_sensitivity (TestWindow* self) {
	GSimpleAction* action = NULL;
	GAction* _tmp0_ = NULL;
	GSimpleAction* _tmp1_ = NULL;
	VteTerminal* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_action_map_lookup_action ((GActionMap*) self, "copy");
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, g_simple_action_get_type ()) ? ((GSimpleAction*) _tmp0_) : NULL);
	action = _tmp1_;
	_tmp2_ = self->priv->terminal;
	_tmp3_ = vte_terminal_get_has_selection (_tmp2_);
	g_simple_action_set_enabled (action, _tmp3_);
	_g_object_unref0 (action);
}


static void test_window_update_paste_sensitivity (TestWindow* self) {
	GdkAtom* targets = NULL;
	gint targets_length1 = 0;
	gint _targets_size_ = 0;
	gboolean can_paste = FALSE;
	GtkClipboard* _tmp0_ = NULL;
	GdkAtom* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	gboolean _tmp3_ = FALSE;
	GSimpleAction* action = NULL;
	GAction* _tmp6_ = NULL;
	GSimpleAction* _tmp7_ = NULL;
	gboolean _tmp8_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->clipboard;
	_tmp3_ = gtk_clipboard_wait_for_targets (_tmp0_, &_tmp1_, &_tmp2_);
	targets = (g_free (targets), NULL);
	targets = _tmp1_;
	targets_length1 = _tmp2_;
	_targets_size_ = targets_length1;
	if (_tmp3_) {
		GdkAtom* _tmp4_ = NULL;
		gint _tmp4__length1 = 0;
		gboolean _tmp5_ = FALSE;
		_tmp4_ = targets;
		_tmp4__length1 = targets_length1;
		_tmp5_ = gtk_targets_include_text (_tmp4_, _tmp4__length1);
		can_paste = _tmp5_;
	} else {
		can_paste = FALSE;
	}
	_tmp6_ = g_action_map_lookup_action ((GActionMap*) self, "paste");
	_tmp7_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp6_, g_simple_action_get_type ()) ? ((GSimpleAction*) _tmp6_) : NULL);
	action = _tmp7_;
	_tmp8_ = can_paste;
	g_simple_action_set_enabled (action, _tmp8_);
	_g_object_unref0 (action);
	targets = (g_free (targets), NULL);
}


static void test_window_update_geometry (TestWindow* self) {
	gboolean _tmp0_ = FALSE;
	VteTerminal* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	VteTerminal* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = test_app_options_no_geometry_hints;
	if (_tmp0_) {
		return;
	}
	_tmp1_ = self->priv->terminal;
	_tmp2_ = gtk_widget_get_realized ((GtkWidget*) _tmp1_);
	if (!_tmp2_) {
		return;
	}
	_tmp3_ = self->priv->terminal;
	vte_terminal_set_geometry_hints_for_window (_tmp3_, (GtkWindow*) self);
}


static void test_window_action_copy_cb (TestWindow* self) {
	VteTerminal* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->terminal;
	vte_terminal_copy_clipboard (_tmp0_);
}


static void test_window_action_copy_match_cb (TestWindow* self, GSimpleAction* action, GVariant* parameter) {
	gsize len = 0UL;
	const gchar* str = NULL;
	GVariant* _tmp0_ = NULL;
	gsize _tmp1_ = 0UL;
	const gchar* _tmp2_ = NULL;
	GtkClipboard* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = parameter;
	_tmp2_ = g_variant_get_string (_tmp0_, &_tmp1_);
	len = _tmp1_;
	str = _tmp2_;
	_tmp3_ = self->priv->clipboard;
	gtk_clipboard_set_text (_tmp3_, str, (gint) len);
}


static void test_window_action_paste_cb (TestWindow* self) {
	VteTerminal* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->terminal;
	vte_terminal_paste_clipboard (_tmp0_);
}


static void test_window_action_reset_cb (TestWindow* self, GSimpleAction* action, GVariant* parameter) {
	gboolean clear = FALSE;
	GdkModifierType modifiers = 0;
	GVariant* _tmp0_ = NULL;
	VteTerminal* _tmp6_ = NULL;
	gboolean _tmp7_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = parameter;
	if (_tmp0_ != NULL) {
		GVariant* _tmp1_ = NULL;
		gboolean _tmp2_ = FALSE;
		_tmp1_ = parameter;
		_tmp2_ = g_variant_get_boolean (_tmp1_);
		clear = _tmp2_;
	} else {
		GdkModifierType _tmp3_ = 0;
		gboolean _tmp4_ = FALSE;
		_tmp4_ = gtk_get_current_event_state (&_tmp3_);
		modifiers = _tmp3_;
		if (_tmp4_) {
			GdkModifierType _tmp5_ = 0;
			_tmp5_ = modifiers;
			clear = (_tmp5_ & GDK_CONTROL_MASK) != 0;
		} else {
			clear = FALSE;
		}
	}
	_tmp6_ = self->priv->terminal;
	_tmp7_ = clear;
	vte_terminal_reset (_tmp6_, TRUE, _tmp7_);
}


static void test_window_action_find_cb (TestWindow* self) {
	GtkToggleButton* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->find_button;
	gtk_toggle_button_set_active (_tmp0_, TRUE);
}


static void test_window_action_quit_cb (TestWindow* self) {
	g_return_if_fail (self != NULL);
	gtk_widget_destroy ((GtkWidget*) self);
}


static gboolean test_window_popup_menu_cb (TestWindow* self) {
	gboolean result = FALSE;
	guint32 _tmp0_ = 0U;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = gtk_get_current_event_time ();
	_tmp1_ = test_window_show_context_menu (self, (guint) 0, _tmp0_, NULL);
	result = _tmp1_;
	return result;
}


static gboolean test_window_button_press_event_cb (TestWindow* self, GtkWidget* widget, GdkEventButton* event) {
	gboolean result = FALSE;
	GdkEventButton* _tmp0_ = NULL;
	guint _tmp1_ = 0U;
	GdkEventButton* _tmp2_ = NULL;
	guint _tmp3_ = 0U;
	GdkEventButton* _tmp4_ = NULL;
	guint32 _tmp5_ = 0U;
	GdkEventButton* _tmp6_ = NULL;
	gboolean _tmp7_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (widget != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = event;
	_tmp1_ = _tmp0_->button;
	if (_tmp1_ != ((guint) 3)) {
		result = FALSE;
		return result;
	}
	_tmp2_ = event;
	_tmp3_ = _tmp2_->button;
	_tmp4_ = event;
	_tmp5_ = _tmp4_->time;
	_tmp6_ = event;
	_tmp7_ = test_window_show_context_menu (self, _tmp3_, _tmp5_, (GdkEvent*) _tmp6_);
	result = _tmp7_;
	return result;
}


static gboolean test_window_show_context_menu (TestWindow* self, guint button, guint32 timestamp, GdkEvent* event) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	GMenu* menu = NULL;
	GMenu* _tmp1_ = NULL;
	GMenu* _tmp2_ = NULL;
	GdkEvent* _tmp3_ = NULL;
	GMenu* _tmp12_ = NULL;
	GtkMenu* popup = NULL;
	GMenu* _tmp13_ = NULL;
	GtkMenu* _tmp14_ = NULL;
	GtkMenu* _tmp15_ = NULL;
	GtkMenu* _tmp16_ = NULL;
	guint _tmp17_ = 0U;
	guint32 _tmp18_ = 0U;
	guint _tmp19_ = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = test_app_options_no_context_menu;
	if (_tmp0_) {
		result = FALSE;
		return result;
	}
	_tmp1_ = g_menu_new ();
	menu = _tmp1_;
	_tmp2_ = menu;
	g_menu_append (_tmp2_, "_Copy", "win.copy");
	_tmp3_ = event;
	if (_tmp3_ != NULL) {
		gchar* match = NULL;
		VteTerminal* _tmp4_ = NULL;
		GdkEvent* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		_tmp4_ = self->priv->terminal;
		_tmp5_ = event;
		_tmp6_ = vte_terminal_match_check_event (_tmp4_, _tmp5_, NULL);
		match = _tmp6_;
		_tmp7_ = match;
		if (_tmp7_ != NULL) {
			GMenu* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			gchar* _tmp10_ = NULL;
			gchar* _tmp11_ = NULL;
			_tmp8_ = menu;
			_tmp9_ = match;
			_tmp10_ = g_strconcat ("win.copy-match::", _tmp9_, NULL);
			_tmp11_ = _tmp10_;
			g_menu_append (_tmp8_, "Copy _Match", _tmp11_);
			_g_free0 (_tmp11_);
		}
		_g_free0 (match);
	}
	_tmp12_ = menu;
	g_menu_append (_tmp12_, "_Paste", "win.paste");
	_tmp13_ = menu;
	_tmp14_ = (GtkMenu*) gtk_menu_new_from_model ((GMenuModel*) _tmp13_);
	g_object_ref_sink (_tmp14_);
	popup = _tmp14_;
	_tmp15_ = popup;
	gtk_menu_attach_to_widget (_tmp15_, (GtkWidget*) self, NULL);
	_tmp16_ = popup;
	_tmp17_ = button;
	_tmp18_ = timestamp;
	gtk_menu_popup (_tmp16_, NULL, NULL, NULL, NULL, _tmp17_, _tmp18_);
	_tmp19_ = button;
	if (_tmp19_ == ((guint) 0)) {
		GtkMenu* _tmp20_ = NULL;
		_tmp20_ = popup;
		gtk_menu_shell_select_first ((GtkMenuShell*) _tmp20_, TRUE);
	}
	result = TRUE;
	_g_object_unref0 (popup);
	_g_object_unref0 (menu);
	return result;
}


static void test_window_char_size_changed_cb (TestWindow* self, VteTerminal* terminal, guint width, guint height) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	test_window_update_geometry (self);
}


static void test_window_child_exited_cb (TestWindow* self, VteTerminal* terminal, gint status) {
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp11_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	_tmp0_ = status;
	g_printerr ("Child exited with status %x\n", (guint) _tmp0_);
	_tmp1_ = test_app_options_output_filename;
	if (_tmp1_ != NULL) {
		{
			GFile* file = NULL;
			const gchar* _tmp2_ = NULL;
			GFile* _tmp3_ = NULL;
			GFileOutputStream* stream = NULL;
			GFile* _tmp4_ = NULL;
			GFileOutputStream* _tmp5_ = NULL;
			VteTerminal* _tmp6_ = NULL;
			GFileOutputStream* _tmp7_ = NULL;
			_tmp2_ = test_app_options_output_filename;
			_tmp3_ = g_file_new_for_commandline_arg (_tmp2_);
			file = _tmp3_;
			_tmp4_ = file;
			_tmp5_ = g_file_replace (_tmp4_, NULL, FALSE, G_FILE_CREATE_NONE, NULL, &_inner_error_);
			stream = _tmp5_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (file);
				goto __catch7_g_error;
			}
			_tmp6_ = terminal;
			_tmp7_ = stream;
			vte_terminal_write_contents_sync (_tmp6_, (GOutputStream*) _tmp7_, VTE_WRITE_DEFAULT, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (stream);
				_g_object_unref0 (file);
				goto __catch7_g_error;
			}
			_g_object_unref0 (stream);
			_g_object_unref0 (file);
		}
		goto __finally7;
		__catch7_g_error:
		{
			GError* e = NULL;
			const gchar* _tmp8_ = NULL;
			GError* _tmp9_ = NULL;
			const gchar* _tmp10_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp8_ = test_app_options_output_filename;
			_tmp9_ = e;
			_tmp10_ = _tmp9_->message;
			g_printerr ("Failed to write output to \"%s\": %s\n", _tmp8_, _tmp10_);
			_g_error_free0 (e);
		}
		__finally7:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp11_ = test_app_options_keep;
	if (_tmp11_) {
		return;
	}
	gtk_widget_destroy ((GtkWidget*) self);
}


static void test_window_clipboard_owner_change_cb (TestWindow* self, GtkClipboard* clipboard, GdkEvent* event) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (clipboard != NULL);
	g_return_if_fail (event != NULL);
	test_window_update_paste_sensitivity (self);
}


static void test_window_decrease_font_size_cb (TestWindow* self, VteTerminal* terminal) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	test_window_adjust_font_size (self, 1.0 / 1.2);
}


void test_window_deiconify_window_cb (TestWindow* self, VteTerminal* terminal) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	gtk_window_deiconify ((GtkWindow*) self);
}


static void test_window_icon_title_changed_cb (TestWindow* self, VteTerminal* terminal) {
	GdkWindow* _tmp0_ = NULL;
	VteTerminal* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	_tmp0_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp1_ = terminal;
	_tmp2_ = vte_terminal_get_icon_title (_tmp1_);
	gdk_window_set_icon_name (_tmp0_, _tmp2_);
}


static void test_window_iconify_window_cb (TestWindow* self, VteTerminal* terminal) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	gtk_window_iconify ((GtkWindow*) self);
}


static void test_window_increase_font_size_cb (TestWindow* self, VteTerminal* terminal) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	test_window_adjust_font_size (self, 1.2);
}


static void test_window_lower_window_cb (TestWindow* self, VteTerminal* terminal) {
	gboolean _tmp0_ = FALSE;
	GdkWindow* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	_tmp0_ = gtk_widget_get_realized ((GtkWidget*) self);
	if (!_tmp0_) {
		return;
	}
	_tmp1_ = gtk_widget_get_window ((GtkWidget*) self);
	gdk_window_lower (_tmp1_);
}


static void test_window_maximize_window_cb (TestWindow* self, VteTerminal* terminal) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	gtk_window_maximize ((GtkWindow*) self);
}


static void test_window_move_window_cb (TestWindow* self, VteTerminal* terminal, guint x, guint y) {
	guint _tmp0_ = 0U;
	guint _tmp1_ = 0U;
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	_tmp0_ = x;
	_tmp1_ = y;
	gtk_window_move ((GtkWindow*) self, (gint) _tmp0_, (gint) _tmp1_);
}


static void test_window_notify_cb (TestWindow* self, GObject* object, GParamSpec* pspec) {
	GParamSpec* _tmp0_ = NULL;
	GType _tmp1_ = 0UL;
	GValue value = {0};
	GParamSpec* _tmp2_ = NULL;
	GType _tmp3_ = 0UL;
	GValue _tmp4_ = {0};
	GObject* _tmp5_ = NULL;
	GParamSpec* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	gchar* str = NULL;
	gchar* _tmp8_ = NULL;
	GParamSpec* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (object != NULL);
	g_return_if_fail (pspec != NULL);
	_tmp0_ = pspec;
	_tmp1_ = _tmp0_->owner_type;
	if (_tmp1_ != vte_terminal_get_type ()) {
		return;
	}
	_tmp2_ = pspec;
	_tmp3_ = _tmp2_->value_type;
	g_value_init (&_tmp4_, _tmp3_);
	value = _tmp4_;
	_tmp5_ = object;
	_tmp6_ = pspec;
	_tmp7_ = _tmp6_->name;
	g_object_get_property (_tmp5_, _tmp7_, &value);
	_tmp8_ = g_strdup_value_contents (&value);
	str = _tmp8_;
	_tmp9_ = pspec;
	_tmp10_ = _tmp9_->name;
	_tmp11_ = str;
	g_print ("NOTIFY property \"%s\" value %s\n", _tmp10_, _tmp11_);
	_g_free0 (str);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
}


static void test_window_raise_window_cb (TestWindow* self, VteTerminal* terminal) {
	gboolean _tmp0_ = FALSE;
	GdkWindow* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	_tmp0_ = gtk_widget_get_realized ((GtkWidget*) self);
	if (!_tmp0_) {
		return;
	}
	_tmp1_ = gtk_widget_get_window ((GtkWidget*) self);
	gdk_window_raise (_tmp1_);
}


static void test_window_realize_cb (TestWindow* self, GtkWidget* widget) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	test_window_update_geometry (self);
}


static void test_window_refresh_window_cb (TestWindow* self, VteTerminal* terminal) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	gtk_widget_queue_draw ((GtkWidget*) self);
}


static void test_window_resize_window_cb (TestWindow* self, VteTerminal* terminal, guint columns, guint rows) {
	gboolean _tmp0_ = FALSE;
	guint _tmp1_ = 0U;
	VteTerminal* _tmp3_ = NULL;
	guint _tmp4_ = 0U;
	guint _tmp5_ = 0U;
	guint _tmp6_ = 0U;
	guint _tmp7_ = 0U;
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	_tmp1_ = columns;
	if (_tmp1_ < ((guint) 2)) {
		_tmp0_ = TRUE;
	} else {
		guint _tmp2_ = 0U;
		_tmp2_ = rows;
		_tmp0_ = _tmp2_ < ((guint) 2);
	}
	if (_tmp0_) {
		return;
	}
	_tmp3_ = terminal;
	_tmp4_ = columns;
	_tmp5_ = rows;
	vte_terminal_set_size (_tmp3_, (glong) ((gint) _tmp4_), (glong) ((gint) _tmp5_));
	_tmp6_ = columns;
	_tmp7_ = rows;
	gtk_window_resize_to_geometry ((GtkWindow*) self, (gint) _tmp6_, (gint) _tmp7_);
}


static void test_window_restore_window_cb (TestWindow* self, VteTerminal* terminal) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	gtk_window_unmaximize ((GtkWindow*) self);
}


static void test_window_selection_changed_cb (TestWindow* self, VteTerminal* terminal) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	test_window_update_copy_sensitivity (self);
}


static void test_window_window_title_changed_cb (TestWindow* self, VteTerminal* terminal) {
	VteTerminal* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (terminal != NULL);
	_tmp0_ = terminal;
	_tmp1_ = vte_terminal_get_window_title (_tmp0_);
	gtk_window_set_title ((GtkWindow*) self, _tmp1_);
}


static void test_window_class_init (TestWindowClass * klass) {
	gint TestWindow_private_offset;
	test_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (TestWindowPrivate));
	G_OBJECT_CLASS (klass)->finalize = test_window_finalize;
	TestWindow_private_offset = g_type_class_get_instance_private_offset (klass);
	gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass), "/org/gnome/vte/test/app/ui/window.ui");
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "scrollbar", FALSE, TestWindow_private_offset + G_STRUCT_OFFSET (TestWindowPrivate, scrollbar));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "terminal_box", FALSE, TestWindow_private_offset + G_STRUCT_OFFSET (TestWindowPrivate, terminal_box));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "readonly_emblem", FALSE, TestWindow_private_offset + G_STRUCT_OFFSET (TestWindowPrivate, readonly_emblem));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "find_button", FALSE, TestWindow_private_offset + G_STRUCT_OFFSET (TestWindowPrivate, find_button));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "gear_button", FALSE, TestWindow_private_offset + G_STRUCT_OFFSET (TestWindowPrivate, gear_button));
}


static void test_window_instance_init (TestWindow * self) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	self->priv = TEST_WINDOW_GET_PRIVATE (self);
	_tmp0_ = g_strdup ("(((gopher|news|telnet|nntp|file|http|ftp|https)://)|(www|ftp)[-A-Za-z0" \
"-9]*\\.)[-A-Za-z0-9\\.]+(:[0-9]*)?");
	_tmp1_ = g_strdup ("(((gopher|news|telnet|nntp|file|http|ftp|https)://)|(www|ftp)[-A-Za-z0" \
"-9]*\\.)[-A-Za-z0-9\\.]+(:[0-9]*)?/[-A-Za-z0-9_\\$\\.\\+\\!\\*\\(\\),;" \
":@&=\\?/~\\#\\%]*[^]'\\.}>\\) ,\\\"]");
	_tmp2_ = g_new0 (gchar*, 2 + 1);
	_tmp2_[0] = _tmp0_;
	_tmp2_[1] = _tmp1_;
	self->priv->builtin_dingus = _tmp2_;
	self->priv->builtin_dingus_length1 = 2;
	self->priv->_builtin_dingus_size_ = self->priv->builtin_dingus_length1;
	gtk_widget_init_template (GTK_WIDGET (self));
}


static void test_window_finalize (GObject* obj) {
	TestWindow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TEST_TYPE_WINDOW, TestWindow);
	_g_object_unref0 (self->priv->scrollbar);
	_g_object_unref0 (self->priv->terminal_box);
	_g_object_unref0 (self->priv->readonly_emblem);
	_g_object_unref0 (self->priv->find_button);
	_g_object_unref0 (self->priv->gear_button);
	_g_object_unref0 (self->priv->terminal);
	_g_object_unref0 (self->priv->clipboard);
	_g_object_unref0 (self->priv->search_popover);
	self->priv->builtin_dingus = (_vala_array_free (self->priv->builtin_dingus, self->priv->builtin_dingus_length1, (GDestroyNotify) g_free), NULL);
	G_OBJECT_CLASS (test_window_parent_class)->finalize (obj);
}


GType test_window_get_type (void) {
	static volatile gsize test_window_type_id__volatile = 0;
	if (g_once_init_enter (&test_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TestWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) test_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TestWindow), 0, (GInstanceInitFunc) test_window_instance_init, NULL };
		GType test_window_type_id;
		test_window_type_id = g_type_register_static (gtk_application_window_get_type (), "TestWindow", &g_define_type_info, 0);
		g_once_init_leave (&test_window_type_id__volatile, test_window_type_id);
	}
	return test_window_type_id__volatile;
}


TestApp* test_app_construct (GType object_type) {
	TestApp * self = NULL;
	GtkSettings* settings = NULL;
	GtkSettings* _tmp0_ = NULL;
	GtkSettings* _tmp1_ = NULL;
	self = (TestApp*) g_object_new (object_type, "application-id", "org.gnome.Vte.Test.App", "flags", G_APPLICATION_NON_UNIQUE, NULL);
	_tmp0_ = gtk_settings_get_default ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	settings = _tmp1_;
	g_object_set (settings, "gtk-enable-mnemonics", FALSE, NULL);
	g_object_set (settings, "gtk-enable-accels", FALSE, NULL);
	g_object_set (settings, "gtk-menu-bar-accel", NULL, NULL);
	_g_object_unref0 (settings);
	return self;
}


TestApp* test_app_new (void) {
	return test_app_construct (TEST_TYPE_APP);
}


static void test_app_real_startup (GApplication* base) {
	TestApp * self;
	self = (TestApp*) base;
	G_APPLICATION_CLASS (test_app_parent_class)->startup ((GApplication*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_application_get_type (), GtkApplication));
	{
		guint i = 0U;
		i = (guint) 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				guint _tmp2_ = 0U;
				gint _tmp3_ = 0;
				gint _tmp4_ = 0;
				TestWindow* _tmp5_ = NULL;
				TestWindow* _tmp6_ = NULL;
				if (!_tmp0_) {
					guint _tmp1_ = 0U;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp2_ = i;
				_tmp3_ = test_app_options_n_windows;
				_tmp4_ = CLAMP (_tmp3_, 0, 16);
				if (!(_tmp2_ < ((guint) _tmp4_))) {
					break;
				}
				_tmp5_ = test_window_new (self);
				g_object_ref_sink (_tmp5_);
				_tmp6_ = _tmp5_;
				_g_object_unref0 (_tmp6_);
			}
		}
	}
}


static void test_app_real_activate (GApplication* base) {
	TestApp * self;
	GList* _tmp0_ = NULL;
	self = (TestApp*) base;
	_tmp0_ = gtk_application_get_windows ((GtkApplication*) self);
	{
		GList* win_collection = NULL;
		GList* win_it = NULL;
		win_collection = _tmp0_;
		for (win_it = win_collection; win_it != NULL; win_it = win_it->next) {
			GtkWindow* _tmp1_ = NULL;
			GtkWindow* win = NULL;
			_tmp1_ = _g_object_ref0 ((GtkWindow*) win_it->data);
			win = _tmp1_;
			{
				GtkWindow* _tmp2_ = NULL;
				TestWindow* window = NULL;
				GtkWindow* _tmp3_ = NULL;
				TestWindow* _tmp4_ = NULL;
				TestWindow* _tmp5_ = NULL;
				TestWindow* _tmp6_ = NULL;
				TestWindow* _tmp7_ = NULL;
				_tmp2_ = win;
				if (!G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, TEST_TYPE_WINDOW)) {
					_g_object_unref0 (win);
					continue;
				}
				_tmp3_ = win;
				_tmp4_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, TEST_TYPE_WINDOW) ? ((TestWindow*) _tmp3_) : NULL);
				window = _tmp4_;
				_tmp5_ = window;
				test_window_apply_geometry (_tmp5_);
				_tmp6_ = window;
				gtk_window_present ((GtkWindow*) _tmp6_);
				_tmp7_ = window;
				test_window_launch (_tmp7_);
				_g_object_unref0 (window);
				_g_object_unref0 (win);
			}
		}
	}
}


gint test_app_main (gchar** argv, int argv_length1) {
	gint result = 0;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp12_ = FALSE;
	gboolean _tmp13_ = FALSE;
	TestApp* app = NULL;
	TestApp* _tmp15_ = NULL;
	TestApp* _tmp16_ = NULL;
	gint _tmp17_ = 0;
	GError * _inner_error_ = NULL;
	setlocale (LC_ALL, "");
	_tmp0_ = g_getenv ("VTE_CJK_WIDTH");
	if (_tmp0_ != NULL) {
		g_printerr ("VTE_CJK_WIDTH is not supported anymore, use --cjk-width instead\n");
	}
	_tmp1_ = g_getenv ("G_ENABLE_DIAGNOSTIC");
	if (_tmp1_ == NULL) {
		g_setenv ("G_ENABLE_DIAGNOSTIC", "0", TRUE);
	}
	g_set_prgname ("vte-app");
	g_set_application_name ("Terminal");
	{
		GOptionContext* context = NULL;
		GOptionContext* _tmp2_ = NULL;
		GOptionContext* _tmp3_ = NULL;
		GOptionContext* _tmp4_ = NULL;
		GOptionContext* _tmp5_ = NULL;
		GOptionGroup* _tmp6_ = NULL;
		GOptionContext* _tmp7_ = NULL;
		_tmp2_ = g_option_context_new ("— simple VTE test application");
		context = _tmp2_;
		_tmp3_ = context;
		g_option_context_set_help_enabled (_tmp3_, TRUE);
		_tmp4_ = context;
		g_option_context_add_main_entries (_tmp4_, TEST_APP_OPTIONS_entries, NULL);
		_tmp5_ = context;
		_tmp6_ = gtk_get_option_group (TRUE);
		g_option_context_add_group (_tmp5_, _tmp6_);
		_tmp7_ = context;
		g_option_context_parse (_tmp7_, &argv_length1, &argv, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			gint _tmp8_ = 0;
			_g_option_context_free0 (context);
			if (_inner_error_->domain == G_OPTION_ERROR) {
				goto __catch8_g_option_error;
			}
			_g_option_context_free0 (context);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp8_;
		}
		_g_option_context_free0 (context);
	}
	goto __finally8;
	__catch8_g_option_error:
	{
		GError* e = NULL;
		GError* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp9_ = e;
		_tmp10_ = _tmp9_->message;
		g_printerr ("Error parsing arguments: %s\n", _tmp10_);
		result = 1;
		_g_error_free0 (e);
		return result;
	}
	__finally8:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		gint _tmp11_ = 0;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return _tmp11_;
	}
	_tmp12_ = test_app_options_version;
	if (_tmp12_) {
		g_print ("Simple VTE Test Application %s\n", VERSION);
		result = 0;
		return result;
	}
	_tmp13_ = test_app_options_debug;
	if (_tmp13_) {
		gboolean _tmp14_ = FALSE;
		_tmp14_ = test_app_options_debug;
		gdk_window_set_debug_updates (_tmp14_);
	}
	_tmp15_ = test_app_new ();
	app = _tmp15_;
	_tmp16_ = app;
	_tmp17_ = g_application_run ((GApplication*) _tmp16_, 0, NULL);
	result = _tmp17_;
	_g_object_unref0 (app);
	return result;
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	return test_app_main (argv, argc);
}


static gint test_app_options_parse_enum (GType type, const gchar* str) {
	gint result = 0;
	gint value = 0;
	GEnumClass* enum_klass = NULL;
	GType _tmp0_ = 0UL;
	GTypeClass* _tmp1_ = NULL;
	GEnumValue* enum_value = NULL;
	GEnumClass* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	GEnumValue* _tmp4_ = NULL;
	GEnumValue* _tmp5_ = NULL;
	g_return_val_if_fail (str != NULL, 0);
	value = 0;
	_tmp0_ = type;
	_tmp1_ = g_type_class_ref (_tmp0_);
	enum_klass = (GEnumClass*) _tmp1_;
	_tmp2_ = enum_klass;
	_tmp3_ = str;
	_tmp4_ = g_enum_get_value_by_nick (_tmp2_, _tmp3_);
	enum_value = _tmp4_;
	_tmp5_ = enum_value;
	if (_tmp5_ != NULL) {
		GEnumValue* _tmp6_ = NULL;
		gint _tmp7_ = 0;
		_tmp6_ = enum_value;
		_tmp7_ = (*_tmp6_).value;
		value = _tmp7_;
	} else {
		const gchar* _tmp8_ = NULL;
		GType _tmp9_ = 0UL;
		GQuark _tmp10_ = 0U;
		const gchar* _tmp11_ = NULL;
		_tmp8_ = str;
		_tmp9_ = type;
		_tmp10_ = g_type_qname (_tmp9_);
		_tmp11_ = g_quark_to_string (_tmp10_);
		g_printerr ("Failed to parse enum value \"%s\" as type \"%s\"\n", _tmp8_, _tmp11_);
	}
	result = value;
	_g_type_class_unref0 (enum_klass);
	return result;
}


gint test_app_options_get_cjk_ambiguous_width (void) {
	gint result = 0;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	_tmp0_ = test_app_options_cjk_ambiguous_width_string;
	if (_tmp0_ == NULL) {
		result = 1;
		return result;
	}
	_tmp1_ = test_app_options_cjk_ambiguous_width_string;
	if (g_strcmp0 (_tmp1_, "narrow") == 0) {
		result = 1;
		return result;
	}
	_tmp2_ = test_app_options_cjk_ambiguous_width_string;
	if (g_strcmp0 (_tmp2_, "wide") == 0) {
		result = 2;
		return result;
	}
	_tmp3_ = test_app_options_cjk_ambiguous_width_string;
	g_printerr ("Failed to parse \"%s\" argument to --cjk-width. Allowed values are \"n" \
"arrow\" or \"wide\".\n", _tmp3_);
	result = 1;
	return result;
}


void test_app_options_get_color_bg (GdkRGBA* result) {
	GdkRGBA color = {0};
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	memset (&color, 0, sizeof (GdkRGBA));
	_tmp0_ = test_app_options_transparency_percent;
	_tmp1_ = CLAMP (_tmp0_, 0, 100);
	color.alpha = ((gdouble) (100 - _tmp1_)) / 100.0;
	_tmp2_ = test_app_options_reverse;
	if (_tmp2_) {
		gdouble _tmp3_ = 0.0;
		gdouble _tmp4_ = 0.0;
		color.blue = 1.0;
		_tmp3_ = color.blue;
		color.green = _tmp3_;
		_tmp4_ = color.green;
		color.red = _tmp4_;
	} else {
		gdouble _tmp5_ = 0.0;
		gdouble _tmp6_ = 0.0;
		color.blue = 0.0;
		_tmp5_ = color.blue;
		color.green = _tmp5_;
		_tmp6_ = color.green;
		color.red = _tmp6_;
	}
	*result = color;
	return;
}


void test_app_options_get_color_fg (GdkRGBA* result) {
	GdkRGBA color = {0};
	gboolean _tmp0_ = FALSE;
	memset (&color, 0, sizeof (GdkRGBA));
	color.alpha = 1.0;
	_tmp0_ = test_app_options_reverse;
	if (_tmp0_) {
		gdouble _tmp1_ = 0.0;
		gdouble _tmp2_ = 0.0;
		color.blue = 0.0;
		_tmp1_ = color.blue;
		color.green = _tmp1_;
		_tmp2_ = color.green;
		color.red = _tmp2_;
	} else {
		gdouble _tmp3_ = 0.0;
		gdouble _tmp4_ = 0.0;
		color.blue = 1.0;
		_tmp3_ = color.blue;
		color.green = _tmp3_;
		_tmp4_ = color.green;
		color.red = _tmp4_;
	}
	*result = color;
	return;
}


static GdkRGBA* _gdk_rgba_dup (GdkRGBA* self) {
	GdkRGBA* dup;
	dup = g_new0 (GdkRGBA, 1);
	memcpy (dup, self, sizeof (GdkRGBA));
	return dup;
}


static gpointer __gdk_rgba_dup0 (gpointer self) {
	return self ? _gdk_rgba_dup (self) : NULL;
}


static GdkRGBA* test_app_options_get_color (const gchar* str) {
	GdkRGBA* result = NULL;
	const gchar* _tmp0_ = NULL;
	GdkRGBA color = {0};
	const gchar* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	GdkRGBA* _tmp4_ = NULL;
	_tmp0_ = str;
	if (_tmp0_ == NULL) {
		result = NULL;
		return result;
	}
	memset (&color, 0, sizeof (GdkRGBA));
	_tmp1_ = str;
	_tmp2_ = gdk_rgba_parse (&color, _tmp1_);
	if (!_tmp2_) {
		const gchar* _tmp3_ = NULL;
		_tmp3_ = str;
		g_printerr ("Failed to parse \"%s\" as color.\n", _tmp3_);
		result = NULL;
		return result;
	}
	_tmp4_ = __gdk_rgba_dup0 (&color);
	result = _tmp4_;
	return result;
}


GdkRGBA* test_app_options_get_color_cursor_background (void) {
	GdkRGBA* result = NULL;
	const gchar* _tmp0_ = NULL;
	GdkRGBA* _tmp1_ = NULL;
	_tmp0_ = test_app_options_cursor_background_color_string;
	_tmp1_ = test_app_options_get_color (_tmp0_);
	result = _tmp1_;
	return result;
}


GdkRGBA* test_app_options_get_color_cursor_foreground (void) {
	GdkRGBA* result = NULL;
	const gchar* _tmp0_ = NULL;
	GdkRGBA* _tmp1_ = NULL;
	_tmp0_ = test_app_options_cursor_foreground_color_string;
	_tmp1_ = test_app_options_get_color (_tmp0_);
	result = _tmp1_;
	return result;
}


GdkRGBA* test_app_options_get_color_hl_bg (void) {
	GdkRGBA* result = NULL;
	const gchar* _tmp0_ = NULL;
	GdkRGBA* _tmp1_ = NULL;
	_tmp0_ = test_app_options_hl_bg_color_string;
	_tmp1_ = test_app_options_get_color (_tmp0_);
	result = _tmp1_;
	return result;
}


GdkRGBA* test_app_options_get_color_hl_fg (void) {
	GdkRGBA* result = NULL;
	const gchar* _tmp0_ = NULL;
	GdkRGBA* _tmp1_ = NULL;
	_tmp0_ = test_app_options_hl_fg_color_string;
	_tmp1_ = test_app_options_get_color (_tmp0_);
	result = _tmp1_;
	return result;
}


VteCursorBlinkMode test_app_options_get_cursor_blink_mode (void) {
	VteCursorBlinkMode result = 0;
	VteCursorBlinkMode value = 0;
	const gchar* _tmp0_ = NULL;
	_tmp0_ = test_app_options_cursor_blink_mode_string;
	if (_tmp0_ != NULL) {
		const gchar* _tmp1_ = NULL;
		gint _tmp2_ = 0;
		_tmp1_ = test_app_options_cursor_blink_mode_string;
		_tmp2_ = test_app_options_parse_enum (vte_cursor_blink_mode_get_type (), _tmp1_);
		value = (VteCursorBlinkMode) _tmp2_;
	} else {
		value = VTE_CURSOR_BLINK_SYSTEM;
	}
	result = value;
	return result;
}


VteCursorShape test_app_options_get_cursor_shape (void) {
	VteCursorShape result = 0;
	VteCursorShape value = 0;
	const gchar* _tmp0_ = NULL;
	_tmp0_ = test_app_options_cursor_shape_string;
	if (_tmp0_ != NULL) {
		const gchar* _tmp1_ = NULL;
		gint _tmp2_ = 0;
		_tmp1_ = test_app_options_cursor_shape_string;
		_tmp2_ = test_app_options_parse_enum (vte_cursor_shape_get_type (), _tmp1_);
		value = (VteCursorShape) _tmp2_;
	} else {
		value = VTE_CURSOR_SHAPE_BLOCK;
	}
	result = value;
	return result;
}


TestAppOptions* test_app_options_dup (const TestAppOptions* self) {
	TestAppOptions* dup;
	dup = g_new0 (TestAppOptions, 1);
	memcpy (dup, self, sizeof (TestAppOptions));
	return dup;
}


void test_app_options_free (TestAppOptions* self) {
	g_free (self);
}


GType test_app_options_get_type (void) {
	static volatile gsize test_app_options_type_id__volatile = 0;
	if (g_once_init_enter (&test_app_options_type_id__volatile)) {
		GType test_app_options_type_id;
		test_app_options_type_id = g_boxed_type_register_static ("TestAppOptions", (GBoxedCopyFunc) test_app_options_dup, (GBoxedFreeFunc) test_app_options_free);
		g_once_init_leave (&test_app_options_type_id__volatile, test_app_options_type_id);
	}
	return test_app_options_type_id__volatile;
}


static void test_app_class_init (TestAppClass * klass) {
	test_app_parent_class = g_type_class_peek_parent (klass);
	((GApplicationClass *) klass)->startup = (void (*)(GApplication*)) test_app_real_startup;
	((GApplicationClass *) klass)->activate = (void (*)(GApplication*)) test_app_real_activate;
}


static void test_app_instance_init (TestApp * self) {
}


GType test_app_get_type (void) {
	static volatile gsize test_app_type_id__volatile = 0;
	if (g_once_init_enter (&test_app_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TestAppClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) test_app_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TestApp), 0, (GInstanceInitFunc) test_app_instance_init, NULL };
		GType test_app_type_id;
		test_app_type_id = g_type_register_static (gtk_application_get_type (), "TestApp", &g_define_type_info, 0);
		g_once_init_leave (&test_app_type_id__volatile, test_app_type_id);
	}
	return test_app_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



